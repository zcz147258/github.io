<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java | mikasa</title><meta name="keywords" content="Java,大数据开发"><meta name="author" content="mikasa"><meta name="copyright" content="mikasa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Java牛逼！">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://yoursite.com/2020/11/30/java/index.html">
<meta property="og:site_name" content="mikasa">
<meta property="og:description" content="Java牛逼！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2756099248,2036703181&fm=26&gp=0.jpg">
<meta property="article:published_time" content="2020-11-30T07:28:46.144Z">
<meta property="article:modified_time" content="2020-11-30T08:51:10.189Z">
<meta property="article:author" content="mikasa">
<meta property="article:tag" content="Java,JavaScript,Node,Json,Sql,前端,数据库,后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2756099248,2036703181&fm=26&gp=0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/11/30/java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-30 16:51:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/index/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/source/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-video"></i><span> 游戏</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-video"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2756099248,2036703181&amp;fm=26&amp;gp=0.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">mikasa</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fas fa-video"></i><span> 游戏</span></a></li><li><a class="site-page" href="/books/"><i class="fa-fw fas fa-video"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-30T07:28:46.144Z" title="发表于 2020-11-30 15:28:46">2020-11-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-30T08:51:10.189Z" title="更新于 2020-11-30 16:51:10">2020-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/source/categories/Java/">Java</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>一.java介绍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java虚拟机   jvm 可以运行在任何操作系统上面 </span><br><span class="line">jdk     是java 程序开发工具包，包含开发人员使用的工具   开发需要 </span><br><span class="line">jre  java程序运行的环境，包含jvm和运行时候的核心类库	运行需要</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jdk =》 包含jre =》 包含 jvm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">程序开发步骤说明</span><br><span class="line">	java源程序----&gt;编译源程序--&gt;java字节码文件---&gt;jvm运行</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	编译用 javac 应用程序.java</span><br><span class="line">	运行用  java 应用程序  省略 <span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>

<h1 id="二-规范"><a href="#二-规范" class="headerlink" title="二.规范"></a>二.规范</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java程序固定</span><br><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;<span class="comment">//文件名保持一致</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//主函数  从这里程序开始执行</span></span><br><span class="line">	<span class="comment">// write your code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三-数据类型"><a href="#三-数据类型" class="headerlink" title="三.数据类型"></a>三.数据类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">基本数据类型</span><br><span class="line">	四类八种</span><br><span class="line">		整数</span><br><span class="line">			<span class="keyword">byte</span>  <span class="keyword">short</span>  <span class="keyword">int</span>   <span class="keyword">long</span></span><br><span class="line">			<span class="number">1</span>字节  <span class="number">2</span>字节  <span class="number">4</span>字节  <span class="number">8</span>字节</span><br><span class="line">		浮点型</span><br><span class="line">			<span class="keyword">float</span> <span class="keyword">double</span>    加后缀</span><br><span class="line">			<span class="number">4</span>字节  <span class="number">8</span>字节</span><br><span class="line">		字符型</span><br><span class="line">			<span class="keyword">char</span>  <span class="number">2</span>字节</span><br><span class="line">		布尔型</span><br><span class="line">			<span class="keyword">boolean</span>  <span class="number">1</span>字节</span><br><span class="line">引用数据类型</span><br><span class="line">	字符串</span><br><span class="line">	数组</span><br><span class="line">	类</span><br><span class="line">	接口</span><br><span class="line">	lamda</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	数据范围和字节数不一定相关， <span class="keyword">float</span> 比 <span class="keyword">long</span> 广泛</span><br><span class="line">	变量一定要进行赋值</span><br></pre></td></tr></table></figure>

<h2 id="3-1数据类型转化"><a href="#3-1数据类型转化" class="headerlink" title="3.1数据类型转化"></a>3.1数据类型转化</h2><h3 id="3-1-1自动转化"><a href="#3-1-1自动转化" class="headerlink" title="3.1.1自动转化"></a>3.1.1自动转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐式转化</span><br><span class="line">	数据范围从小到大    <span class="keyword">long</span> num = <span class="number">100</span>; <span class="keyword">double</span> num2 = <span class="number">2.5F</span>; <span class="keyword">float</span> num3 = <span class="number">30L</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2强制类型转化"><a href="#3-1-2强制类型转化" class="headerlink" title="3.1.2强制类型转化"></a>3.1.2强制类型转化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">范围从大到小</span><br><span class="line">	<span class="keyword">int</span> num = (<span class="keyword">int</span>)<span class="number">100L</span>;</span><br><span class="line">	</span><br><span class="line">	强制类型转化一般不推荐使用，因为可能发生精度损失，数据溢出</span><br><span class="line">	 <span class="keyword">char</span> b = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">     System.out.println(b + <span class="number">1</span>);</span><br><span class="line">     如果<span class="keyword">char</span>/<span class="keyword">byte</span>/<span class="keyword">short</span>/ 类型进行计算的时候，会自动提升为  <span class="keyword">int</span> 再计算</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">boolean</span> 不能发生数据类型转化</span><br></pre></td></tr></table></figure>

<h1 id="四-方法"><a href="#四-方法" class="headerlink" title="四.方法"></a>四.方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义一个方法的格式</span><br><span class="line">	<span class="keyword">public</span> function viod（）&#123;</span><br><span class="line">        方法体</span><br><span class="line">	&#125;</span><br><span class="line">方法的定义不能嵌套</span><br></pre></td></tr></table></figure>

<h2 id="4-1定义"><a href="#4-1定义" class="headerlink" title="4.1定义"></a>4.1定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义方法的完整格式</span><br><span class="line">	修饰符 返回值类型 方法名称 （参数，参数）</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = a + b;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2方法的三种调用方法"><a href="#4-2方法的三种调用方法" class="headerlink" title="4.2方法的三种调用方法"></a>4.2方法的三种调用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>单独调用			方法名称(参数)；</span><br><span class="line"><span class="number">2.</span>打印调用			打印里面调用</span><br><span class="line"><span class="number">3.</span>赋值调用			返回值赋值给另外一个变量</span><br><span class="line"></span><br><span class="line">方法应该定义在类当中，方法不能嵌套，</span><br><span class="line">方法定义的前后顺序无所谓</span><br><span class="line"><span class="keyword">return</span> 后面的返回值类型必须和函数定义的类型一致</span><br><span class="line">对于一个  <span class="keyword">void</span> 方法类型，不能写<span class="keyword">return</span>后面的返回值，可以  <span class="keyword">return</span>；</span><br><span class="line">一个方法可以有多个<span class="keyword">return</span>值，凡是必须保证只有同一个被执行</span><br></pre></td></tr></table></figure>

<h2 id="4-3方法的重载"><a href="#4-3方法的重载" class="headerlink" title="4.3方法的重载"></a>4.3方法的重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">对于功能类似的方法来说，因为参数列表不一样，可以用重载；</span><br><span class="line">overload</span><br><span class="line">多个方法的名字一样，参数有几个那么对应调用有几个参数的方法；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法重载的注意事项相关</span><br><span class="line">	<span class="number">1.</span>参数的个数不同</span><br><span class="line">	<span class="number">2.</span>参数的类型不同，</span><br><span class="line">	<span class="number">3.</span>参数的多类型顺序不同 那么函数构成重载</span><br><span class="line">	<span class="number">4.</span>和函数名字的大小写有关</span><br><span class="line">	</span><br><span class="line">无关因素</span><br><span class="line">	和参数的名称无关</span><br><span class="line">	与方法的返回值类型无关  函数的返回值无关</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="五-idea中快捷键"><a href="#五-idea中快捷键" class="headerlink" title="五.idea中快捷键"></a>五.idea中快捷键</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alt + enter  修复错误</span><br><span class="line">ctrl + y;</span><br><span class="line">格式化代码  ctrl + alt + L;</span><br><span class="line">自动生成代码	alt + ins ；</span><br><span class="line">shift + f6 所有相同变量一起变</span><br><span class="line">alt + enter 可以自动生成错误提示代码</span><br></pre></td></tr></table></figure>

<h1 id="六-数组"><a href="#六-数组" class="headerlink" title="六.数组"></a>六.数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">数组是一种引用数据类型；</span><br><span class="line">数组当中的多个数据，类型必须统一</span><br><span class="line">数组的长度在数组运行期间不能改变；</span><br><span class="line"></span><br><span class="line">数组的定义</span><br><span class="line">	动态初始化指定长度</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">300</span>];能放<span class="number">300</span>个数据；其中的元素将会自动拥有一个默认值</span><br><span class="line">		如果是整数，那么就是 <span class="number">0</span>；</span><br><span class="line">		如果是浮点类型 ，那么就是<span class="number">0.0</span>；</span><br><span class="line">		如果是字符类型，那么就是 ‘\u0000’;</span><br><span class="line">		如果是布尔类型，那就是<span class="keyword">false</span>；</span><br><span class="line">		如果是引用类型，那么就是<span class="keyword">null</span>；</span><br><span class="line">	静态初始化指定内容</span><br><span class="line">		<span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span> &#125;;</span><br><span class="line">		</span><br><span class="line">	省略格式：：：静态初始化  </span><br><span class="line">		<span class="keyword">int</span>[] arr2 = &#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;java&quot;</span>&#125;;</span><br><span class="line">		注意事项，<span class="keyword">int</span>[] arr; arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;拆分两个</span><br><span class="line">	静态初始化一旦省略就不能拆分两个步骤；</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	直接打印数组名称，得到的是数组对应的内存地址，哈希值！！后面出现的是<span class="number">16</span>进制；</span><br></pre></td></tr></table></figure>

<h2 id="6-1同一个数组"><a href="#6-1同一个数组" class="headerlink" title="6.1同一个数组"></a>6.1同一个数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">产生影响</span><br><span class="line">	<span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">15</span>,<span class="number">25</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>[] arr2 = arr1;</span><br><span class="line">	</span><br><span class="line">	方法传参，传数组就是 传地址值；</span><br></pre></td></tr></table></figure>

<h2 id="6-2数组索引越界；空指针异常"><a href="#6-2数组索引越界；空指针异常" class="headerlink" title="6.2数组索引越界；空指针异常"></a>6.2数组索引越界；空指针异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组索引越界</span><br><span class="line">	如果索引不存在，那么就会发生索引越界异常；</span><br><span class="line">空指针异常</span><br><span class="line">	所有引用变量，都可以赋值为以一个<span class="keyword">null</span>值，但是代表其中什么都没有</span><br></pre></td></tr></table></figure>

<h2 id="6-3数组方法"><a href="#6-3数组方法" class="headerlink" title="6.3数组方法"></a>6.3数组方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印数组  调用 jdk库 Arrays.toString(arr);</span><br></pre></td></tr></table></figure>

<h2 id="6-4-Arrays"><a href="#6-4-Arrays" class="headerlink" title="6.4 Arrays"></a>6.4 Arrays</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一个和数组相关的工具类，里面提供了大量的静态方法；</span><br><span class="line">	toString();  将参数数组变成字符串</span><br><span class="line">	sort();  默认升序，排序  数值按照升序从小到大，如果是字母按照升序</span><br><span class="line">			如果是自定义类型，那么这个自定义类型需要comparable接口的支持</span><br></pre></td></tr></table></figure>



<h1 id="七-java的内存"><a href="#七-java的内存" class="headerlink" title="七.java的内存"></a>七.java的内存</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">划分为五个内存；</span><br><span class="line"><span class="number">1.</span>栈内存  stack ： 存放的都是方法中的局部变量</span><br><span class="line">				局部变量，就是&#123;&#125;内部的变量；</span><br><span class="line">				作用域，一旦超出作用域；立刻从栈内存中消失；</span><br><span class="line">				方法的运行都是在栈当中</span><br><span class="line"><span class="number">2.</span>堆内存 heap  ; 凡是<span class="keyword">new</span>出来的东西，都在堆内存中间</span><br><span class="line">				堆内存里面的东西都有一个地址值</span><br><span class="line">				堆内存里面的数据都有一个默认值</span><br><span class="line">                    如果是整数，那么就是 <span class="number">0</span>；</span><br><span class="line">                    如果是浮点类型 ，那么就是<span class="number">0.0</span>；</span><br><span class="line">                    如果是字符类型，那么就是 ‘\u0000’;</span><br><span class="line">                    如果是布尔类型，那就是<span class="keyword">false</span>；</span><br><span class="line">                    如果是引用类型，那么就是<span class="keyword">null</span>；</span><br><span class="line"> <span class="number">3.</span>方法区： 存储<span class="class"><span class="keyword">class</span>相关信息，包含方法信息</span></span><br><span class="line"><span class="class"> 4.本地方法栈  与操作系统相关</span></span><br><span class="line"><span class="class"> 5.寄存器  与<span class="title">CPU</span>相关</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">				</span></span><br><span class="line"><span class="class">	类是对象的模板，对象是类的实体</span></span><br></pre></td></tr></table></figure>

<h1 id="八-类"><a href="#八-类" class="headerlink" title="八.类"></a>八.类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">定义类   </span><br><span class="line">		定义在方法区</span><br><span class="line">		属性（是什么）	姓名 年龄    具体保存在堆里面</span><br><span class="line">		行为（能做什么）学习  吃饭 睡觉   具体保存在堆里面</span><br><span class="line">    对应到 java的类中</span><br><span class="line">		成员变量，（属性）</span><br><span class="line">		成员方法（行为）<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;  没有<span class="keyword">static</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">            String name;</span><br><span class="line">            <span class="keyword">int</span> age;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		注意： 成员变量直接定义在类中，</span><br><span class="line">				成员方法不要写 <span class="keyword">static</span> 关键字</span><br><span class="line">				</span><br><span class="line">		通常情况下，一个类不能直接使用，需要根据一个类来实现，</span><br><span class="line">			<span class="number">1.</span>导包，			<span class="keyword">import</span>   包名称.类名称 同一个包可以省略导包语句</span><br><span class="line">			<span class="number">2.</span>创建，			Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">			<span class="number">3.</span>使用			</span><br><span class="line">				两种情况</span><br><span class="line">						使用成员变量	对象.变量名</span><br><span class="line">						使用成员方法	对象.方法名</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">						</span><br><span class="line">	压栈</span><br><span class="line">		方法执行在栈中，成员变量直接存储在堆中，成员方法的地址存在堆中，运行找到地址，然后去方法区里面找方法，压栈到栈内存中开始执行</span><br></pre></td></tr></table></figure>

<h2 id="8-1变量的区别"><a href="#8-1变量的区别" class="headerlink" title="8.1变量的区别"></a>8.1变量的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义的位置不一样  </span><br><span class="line">	局部变量 方法内部</span><br><span class="line">	成员变量 在方法的外部，直接写在类中</span><br><span class="line">作用范围不一样</span><br><span class="line">	局部变量	只有方法当中才可以使用</span><br><span class="line">	成员变量	整个类都可以用</span><br><span class="line">默认值不一样</span><br><span class="line">	局部变量	没有默认值 必须手动赋值</span><br><span class="line">	成员变量	如果没有赋值，规则和数组一样 </span><br></pre></td></tr></table></figure>

<h2 id="8-2面向对象三大特征-封装"><a href="#8-2面向对象三大特征-封装" class="headerlink" title="8.2面向对象三大特征 封装"></a>8.2面向对象三大特征 封装</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在java中的体现</span><br><span class="line">	<span class="number">1.</span>方法就是一种分装</span><br><span class="line">	<span class="number">2.</span>关键字<span class="keyword">private</span>也是一种封装</span><br><span class="line">	</span><br><span class="line">	无法阻止不合理的数值设置进来，用<span class="keyword">private</span>关键字将需要保护的成员变量修饰</span><br><span class="line">	一旦使用<span class="keyword">private</span>进行修饰，在本类中可以随意访问，但是超过了本类范围之外就不能访问</span><br><span class="line">	<span class="keyword">private</span>关键字的使用</span><br><span class="line">	</span><br><span class="line">		只能通过间接访问，间接访问必须是setxxx或者getxxx get不能有参数，set不能有返回值</span><br><span class="line">			访问方法修改属性</span><br><span class="line">	注意事项</span><br><span class="line">		对于基本数据类型当中的  布尔类型 get方法一定要写成 isxxx的方法</span><br></pre></td></tr></table></figure>

<h2 id="8-3-this"><a href="#8-3-this" class="headerlink" title="8.3 this"></a>8.3 this</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量</span><br><span class="line">如果需要访问本类的变量，需要使用格式</span><br><span class="line">	<span class="keyword">this</span>.成员变量名 </span><br><span class="line">	注意： <span class="keyword">this</span> 一定是写在方法内部的</span><br><span class="line">				通过谁调用的方法，就是谁的<span class="keyword">this</span></span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">	<span class="keyword">this</span>的用法</span><br><span class="line">		访问本类内容</span><br><span class="line">		<span class="number">1.</span>在本类的成员方法中访问本类的成员变量</span><br><span class="line">		<span class="number">2.</span>在本类的成员方法中访问本类的另一个成员方法</span><br><span class="line">		<span class="number">3.</span>在本类的构造方法中访问本类的另一个构造方法 只能调用一个构造</span><br><span class="line">		<span class="keyword">super</span>和<span class="keyword">this</span>两种构造调用，不能同时使用</span><br></pre></td></tr></table></figure>

<h2 id="8-4构造方法"><a href="#8-4构造方法" class="headerlink" title="8.4构造方法"></a>8.4构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">构造方法是专门用来创建对象的方法，当我们用关键字<span class="keyword">new</span>来创建对象的时候，其实就是在调用构造方法</span><br><span class="line">	格式</span><br><span class="line">		<span class="keyword">public</span> 类名字（参数类型 参数名称）&#123;</span><br><span class="line">            方法体</span><br><span class="line">		&#125;</span><br><span class="line">	注意</span><br><span class="line">		构造方法的名称必须和类名一致</span><br><span class="line">		构造方法不要写返回值类型，连<span class="keyword">void</span>都不用写</span><br><span class="line">		构造方法不能<span class="keyword">return</span>返回值</span><br><span class="line">		如果没有编写构造方法，那么就会默认生成一个构造方法，内容为空，参数为空</span><br><span class="line">		构造方法也是可以重载的</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Different</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*构造方法*/</span></span><br><span class="line">            <span class="keyword">private</span> String name;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Different</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">this</span>.age = age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        调用</span><br><span class="line">        	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constru</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                    Different one = <span class="keyword">new</span> Different(<span class="string">&quot;赵丽颖&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println( one.getAge());</span><br><span class="line">                    System.out.println( one.getName());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">标准的类</span><br><span class="line">	<span class="number">1.</span>所有成员变量都要使用<span class="keyword">private</span>关键字修斯</span><br><span class="line">	<span class="number">2.</span>为每一个成员变量添加getter/setter方法</span><br><span class="line">	<span class="number">3.</span>编写一个无参数的构造方法</span><br><span class="line">	<span class="number">4.</span>编写一个全参数的构造方法</span><br><span class="line">	</span><br><span class="line">	也叫做 java bean </span><br><span class="line">	编辑器自动生成</span><br></pre></td></tr></table></figure>

<h2 id="8-4面向对象三大特性-继承"><a href="#8-4面向对象三大特性-继承" class="headerlink" title="8.4面向对象三大特性 继承"></a>8.4面向对象三大特性 继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">继承是多态的前提  继承主要解决的问题就是  共性抽取</span><br><span class="line">	</span><br><span class="line">	java继承的三个特点</span><br><span class="line">		<span class="number">1.</span>一个类的直接父亲只有唯一一个</span><br><span class="line">		<span class="number">2.</span>java可以多级继承</span><br><span class="line">		<span class="number">3.</span>一个父类可以拥有很多个子类</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	父类 基类 超类 </span><br><span class="line"></span><br><span class="line">	子类 派生类</span><br><span class="line">	</span><br><span class="line">	继承的格式</span><br><span class="line">		定义子类 <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名称 <span class="keyword">extends</span> 父类名称</span>&#123;</span><br><span class="line">            </span><br><span class="line">		&#125;</span><br><span class="line">		在父子类的继承关系中，如果成员变量名称重名，则创建子类对象时候，有两种方式</span><br><span class="line">			直接访问 通过子类对象访问成员变量  等号左边是谁，就是谁</span><br><span class="line">			间接访问 通过成员方法访问  看方法属于谁，是谁创建的</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			访问变量</span><br><span class="line">				num   局部变量</span><br><span class="line">				<span class="keyword">this</span>.num 本类的成员变量</span><br><span class="line">				<span class="keyword">super</span>.num 父类的成员变量</span><br><span class="line">			访问方法</span><br><span class="line">				创建的对象是谁，就优先使用谁，如果没有那就向上找</span><br><span class="line">		</span><br><span class="line">	方法的重写  创建的是子类对象，那就优先用子类方法</span><br><span class="line">			<span class="number">1.</span>重写 方法的名称一样，参数列表也一样</span><br><span class="line">			重载 方法的名称一样，参数列表不一样</span><br><span class="line">			</span><br><span class="line">			检测重写 <span class="meta">@Overide</span> 用来检测是不是正确有效的重写 写到函数上面</span><br><span class="line">			</span><br><span class="line">			<span class="number">2.</span>注意事项 ：子类方法的返回值必须小于等于父类方法的返回值范围</span><br><span class="line">			</span><br><span class="line">			<span class="number">3.</span>子类方法的权限必须大于等于父类的权限修饰符</span><br><span class="line">			<span class="keyword">public</span> &gt; <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>) &gt; <span class="keyword">private</span></span><br><span class="line">			</span><br><span class="line">	构造方法父子类访问特点</span><br><span class="line">		<span class="number">1.</span>父类构造方法先执行，子类构造方法后执行 赠送一个<span class="keyword">super</span>执行  无参数</span><br><span class="line">		<span class="number">2.</span>可以通过<span class="keyword">super</span>关键字来子类构造父类 重载构造   </span><br><span class="line">			有参数需要 用<span class="keyword">super</span>(params)  调用</span><br><span class="line">		<span class="number">3.</span><span class="keyword">super</span>的父类构造调用，必须是子类构造方法的第一个语句</span><br><span class="line">			只有子类构造方法才可以调用父类构造方法</span><br><span class="line">			<span class="keyword">super</span>构造只能调用一次</span><br></pre></td></tr></table></figure>

<h2 id="8-5-super"><a href="#8-5-super" class="headerlink" title="8.5 super"></a>8.5 super</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>关键字的三种用法</span><br><span class="line">	<span class="number">1.</span>在子类的成员方法中，访问父类的成员变量  </span><br><span class="line">  <span class="number">2.</span>在子类的成员方法中，访问父类的成员方法</span><br><span class="line">  <span class="number">3.</span>在子类的构造方法中，访问父类的构造方法</span><br></pre></td></tr></table></figure>

<h2 id="8-6抽象-方法abstract"><a href="#8-6抽象-方法abstract" class="headerlink" title="8.6抽象 方法abstract"></a>8.6抽象 方法abstract</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    实例 <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>; <span class="comment">//抽象方法java</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">如何使用抽象类抽象方法</span><br><span class="line">	<span class="number">1.</span>不能直接<span class="keyword">new</span>抽象类对象</span><br><span class="line">	<span class="number">2.</span>必须用一个子类来继承抽象父类</span><br><span class="line">	<span class="number">3.</span>子类必须覆盖重写抽象父类当中的所有抽象方法；</span><br><span class="line">		子类去掉抽象方法的<span class="keyword">abstract</span>关键字，然后补上方法体大括号</span><br><span class="line">	<span class="number">4.</span>创建子类对象进行使用</span><br><span class="line">注意事项</span><br><span class="line">	<span class="number">1.</span>抽象类不能创建对象</span><br><span class="line">	<span class="number">2.</span>抽象类中，可以有构造方法</span><br><span class="line">	<span class="number">3.</span>抽象类中，不一定包含抽象方法</span><br><span class="line">	<span class="number">4.</span>抽象类的子类，必须要重写抽象父类中所有的抽象方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8-7-Object"><a href="#8-7-Object" class="headerlink" title="8.7 Object"></a>8.7 Object</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">是类的根类 </span><br><span class="line">	方法</span><br><span class="line">		toString();</span><br><span class="line">			直接打印的是对象的名字，其实就是调用object的tostring方法</span><br><span class="line">			可以重写 toString方法</span><br><span class="line">			</span><br><span class="line">		equals(); 比较两个对象是否相等</span><br><span class="line">			重写equals（）方法比较 属性值</span><br><span class="line">			向下转型</span><br><span class="line">				<span class="keyword">this</span>.name.equals(obj.name)</span><br></pre></td></tr></table></figure>

<h2 id="8-8-Objects"><a href="#8-8-Objects" class="headerlink" title="8.8 Objects"></a>8.8 Objects</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(obj1,obj2)  </span><br><span class="line">可以避免空指针调用</span><br></pre></td></tr></table></figure>

<h2 id="8-9可变参数"><a href="#8-9可变参数" class="headerlink" title="8.9可变参数"></a>8.9可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当方法的参数列表数据类型已经确定，但是参数的个数不确定，我们就可以使用可变参数</span><br><span class="line"></span><br><span class="line">修饰符 返回值 方法名 (数据类型...变量名)</span><br><span class="line">	底层原理是一个数组，根据传递参数的长短，创建不同长度的数组，来存储这些参数</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>...arr)</span></span>&#123;</span><br><span class="line">        sout(arr)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	注意</span><br><span class="line">	<span class="number">1.</span>，一个方法的参数列表，只能有一个可变参数</span><br><span class="line">	<span class="number">2.</span>如果方法的参数有很多个，那么可变参数必须写在参数的末尾	</span><br></pre></td></tr></table></figure>



<h1 id="九-api的使用"><a href="#九-api的使用" class="headerlink" title="九. api的使用"></a>九. api的使用</h1><h2 id="1-键盘输入Scanner"><a href="#1-键盘输入Scanner" class="headerlink" title="1.键盘输入Scanner"></a>1.键盘输入Scanner</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">引用类型</span><br><span class="line">	<span class="number">1.</span>导包</span><br><span class="line">		<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">		只有java.lang包不需要导包</span><br><span class="line">	<span class="number">2.</span>创建</span><br><span class="line">		代表从键盘输入</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(Syetem.in);</span><br><span class="line">	<span class="number">3.</span>使用</span><br><span class="line">		<span class="keyword">int</span> num = sc.nextInt();键盘输入的都是字符串，但是这个方法可以转化</span><br></pre></td></tr></table></figure>

<h2 id="2-random"><a href="#2-random" class="headerlink" title="2.random"></a>2.random</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>导包</span><br><span class="line">	<span class="keyword">import</span> java.util.Random;</span><br><span class="line">	只有java.lang包不需要导包</span><br><span class="line"><span class="number">2.</span>创建</span><br><span class="line">	代表从键盘输入</span><br><span class="line">	Random sc = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="number">3.</span>使用</span><br><span class="line">	<span class="keyword">int</span> num = sc.nextInt();不带参数，指的是所有范围</span><br><span class="line">	<span class="keyword">int</span> num = sc.nextInt(<span class="number">3</span>);  指的是【<span class="number">0</span>，<span class="number">3</span>)  左闭右开</span><br></pre></td></tr></table></figure>

<h2 id="3-math"><a href="#3-math" class="headerlink" title="3.math"></a>3.math</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.utils.Math是数学相关的工具类</span><br><span class="line">Math.abs() 绝对值</span><br><span class="line">Math.ceil() 向上取整</span><br><span class="line">Math.floor() 向下取整</span><br><span class="line">Math.round() 四舍五入</span><br></pre></td></tr></table></figure>



<h1 id="十-匿名对象"><a href="#十-匿名对象" class="headerlink" title="十.匿名对象"></a>十.匿名对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Hello().name = <span class="string">&quot;赵又廷&quot;</span>;</span><br><span class="line">      System.out.println(<span class="keyword">new</span> Hello().name);</span><br><span class="line">      </span><br><span class="line">      匿名对象只能使用一次，这里创建了两个值</span><br><span class="line">      </span><br><span class="line">      匿名对象作为方法的参数</span><br><span class="line">      匿名对象作为返回值</span><br></pre></td></tr></table></figure>

<h1 id="十一-集合"><a href="#十一-集合" class="headerlink" title="十一.,集合"></a>十一.,集合</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定义一个数组，用来存放对象 集合可以</span><br><span class="line"><span class="number">2.</span>什么是arraylist 和普通数组的区别是可以在运行中变换长度</span><br><span class="line"></span><br><span class="line">只能存  引用类型；</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">创建了一个ArrayList集合，里面装的都是String类型；</span><br><span class="line"></span><br><span class="line">而且打印出来不是地址值，而是内容</span><br><span class="line"></span><br><span class="line">Java中的集合框架大类可分为Collection和Map；两者的区别：</span><br><span class="line"><span class="number">1</span>、Collection是单列集合；Map是双列集合</span><br><span class="line"><span class="number">2</span>、Collection中只有Set系列要求元素唯一；Map中键需要唯一，值可以重复</span><br><span class="line"><span class="number">3</span>、Collection的数据结构是针对元素的；Map的数据结构是针对键的。</span><br><span class="line"></span><br><span class="line">如果有泛型，不使用时，参数的类型会自动提升成Object类型，如果再取出来的话就需要向下强转，就可能发生类型转化异常(ClassCaseException)；不加泛型就不能在编译期限定向集合中添加元素的类型，导致后期的处理麻烦。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实现带有泛型的接口类型：</span><br><span class="line">	<span class="number">1.</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImpl1</span> <span class="keyword">implements</span> <span class="title">GenericInter</span>&lt;<span class="title">String</span>&gt; </span>&#123;&#125;</span><br><span class="line">	<span class="number">2.</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImpl2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">GenericInter</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line">使用泛型的注意点:</span><br><span class="line">	<span class="number">1</span>、泛型不支持基本数据类型</span><br><span class="line">	<span class="number">2</span>、泛型不支持继承，必须保持前后一致（比如这样是错误的：List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="11-1ArrayList"><a href="#11-1ArrayList" class="headerlink" title="11.1ArrayList"></a>11.1ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元素增删慢，查询快，最常用，多线程</span><br><span class="line"></span><br><span class="line">list.add(<span class="string">&quot;赵丽颖&quot;</span>);往最后加一个内容</span><br><span class="line">list.get(<span class="number">2</span>)  返回索引值对应的</span><br><span class="line">list.remove(<span class="number">3</span>)  删除的索引对应，原来的集合就没了</span><br><span class="line">list.size()  得到长度</span><br></pre></td></tr></table></figure>

<h2 id="11-2包装类"><a href="#11-2包装类" class="headerlink" title="11.2包装类"></a>11.2包装类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">如果希望向集合ArrayList中存储基本数据类型，必须使用基本类型对应的包装类</span><br><span class="line">包装类都位于 java.lang包下面</span><br><span class="line"></span><br><span class="line">	Byte Short Integer Long Float Double Character Boolean</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	基本数据类型的数据，没有对应的方法来操作这些数据，</span><br><span class="line">		我们使用一个类，把这些基本数据类型包装起来，叫做包装类</span><br><span class="line">	</span><br><span class="line">	自动装箱	基本类型----&gt;包装类型</span><br><span class="line">	自动拆箱	包装类型----&gt;基本类型</span><br><span class="line">	</span><br><span class="line">	基本类型转化 字符串</span><br><span class="line">			<span class="number">1.</span>toString() </span><br><span class="line">			<span class="number">2.</span>+</span><br><span class="line">			<span class="number">3.</span>valueOf()</span><br><span class="line">	字符串转化为基本类型</span><br><span class="line">	</span><br><span class="line">		Integer.parseInt()</span><br><span class="line">	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="11-3集合"><a href="#11-3集合" class="headerlink" title="11.3集合"></a>11.3集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">集合和数组的区别</span><br><span class="line">	arraylist就是一个集合</span><br><span class="line">	<span class="number">1.</span>数组的长度是固定不变的，集合的长度是可变的</span><br><span class="line">	<span class="number">2.</span>数组中存储的都是同一个类型的元素，可以存储基本数据类型</span><br><span class="line">		集合存储的都是对象，而且对象的类型可以不一致，</span><br><span class="line">		在开发中，当对象比较多时候，可以使用集合进行存储</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	分类 </span><br><span class="line">			<span class="number">1.</span>Vector集合		了解</span><br><span class="line">			<span class="number">2.</span>ArrayList集合	重点			前三个都是List接口</span><br><span class="line">			<span class="number">3.</span>Linkedlist集合		次之</span><br><span class="line">			<span class="number">4.</span>TreeSet集合		了解</span><br><span class="line">			<span class="number">5.</span>HashSet集合		重点			后三个都是三个Set接口</span><br><span class="line">				<span class="number">5.1</span>.LinkedHashSet  次之</span><br><span class="line">	接口</span><br><span class="line">			<span class="number">1.</span>List接口</span><br><span class="line">				有序的集合，取出和存储的顺序一致</span><br><span class="line">				允许存储重复的元素</span><br><span class="line">				有索引，可以使用<span class="keyword">for</span>循环遍历				抽取共性得到Collections接口</span><br><span class="line">			<span class="number">2.</span>Set接口</span><br><span class="line">				不允许存储重复元素</span><br><span class="line">				没有索引</span><br><span class="line">				无序的集合</span><br><span class="line">    学习目标</span><br><span class="line">            <span class="number">1.</span>会使用集合存储数据</span><br><span class="line">            <span class="number">2.</span>会遍历集合，把数据取出来</span><br><span class="line">            <span class="number">3.</span>掌握每一种集合的特性</span><br></pre></td></tr></table></figure>

<h2 id="11-4集合的方法"><a href="#11-4集合的方法" class="headerlink" title="11.4集合的方法"></a>11.4集合的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>arrayList  底层是数组实现的  查询快，增加删除慢</span><br><span class="line"><span class="number">2.</span>linkedlist 底层是链表实现的，查询慢，增删快</span><br><span class="line"><span class="number">3.</span>hashset  底层是哈希表，红黑树实现的，无索引，不可以重复储存，存储无序</span><br><span class="line"><span class="number">4.</span>linkedHashset 底层是哈希表加链表实现的，无索引，不能重复存储，可以保证存储顺序</span><br><span class="line"><span class="number">5.</span>treeset 底层是二叉树实现的，一般用于排序</span><br><span class="line"></span><br><span class="line">add()  向集合中添加元素</span><br><span class="line">remove()  删除集合中某个元素</span><br><span class="line">clear()  清空集合中所有的元素</span><br><span class="line">contains()  判断集合中是否包含某个元素</span><br><span class="line">isEmpty()  判断集合是不是为空</span><br><span class="line">size()    获取集合的长度</span><br><span class="line">toArray()  将集合转化成一个数组  返回的数组是一个object类型的数组</span><br></pre></td></tr></table></figure>

<h2 id="11-5-iterator迭代器"><a href="#11-5-iterator迭代器" class="headerlink" title="11.5 iterator迭代器"></a>11.5 iterator迭代器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">迭代的概念</span><br><span class="line">	再取出元素之前判断集合之中有没有元素，如果有，就把这个元素取出来，然后继续判断，如果还有那么继续取；</span><br><span class="line">	这种专业术语成为迭代</span><br><span class="line">	</span><br><span class="line">	通过集合接口中 interator()来返回实现类对象</span><br><span class="line">	</span><br><span class="line">	两个常用方法</span><br><span class="line">		hasNext()  集合中还有没有下一个元素，返回布尔值</span><br><span class="line">		next()  返回迭代的下一个元素</span><br><span class="line">		</span><br><span class="line">	迭代器的泛型跟着集合走，集合什么泛型，迭代器就是什么泛型</span><br><span class="line">	Iterator&lt;String&gt; it = coll.iterator()   <span class="comment">//多态</span></span><br><span class="line">	it.hasnext()  判断有没有元素</span><br><span class="line">	it.next();</span><br><span class="line">	没有元素再取出元素就会抛出异常</span><br></pre></td></tr></table></figure>

<h2 id="11-6增强for循环-foreach"><a href="#11-6增强for循环-foreach" class="headerlink" title="11.6增强for循环  foreach"></a>11.6增强for循环  foreach</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">	<span class="keyword">for</span>(集合/数组  变量名：集合名/数组名)&#123;</span><br><span class="line">        变量名</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span>[] i:arr)&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-7泛型"><a href="#11-7泛型" class="headerlink" title="11.7泛型"></a>11.7泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">是一种位置的数据类型，不知道使用什么数据类型的时候，使用泛型</span><br><span class="line">泛型也可以看作一个变量，用来接收数据</span><br><span class="line"></span><br><span class="line">	E；未知的数据类型 </span><br><span class="line">		创建集合的时候，E就确定为 字符串</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	使用泛型的好处</span><br><span class="line">		<span class="number">1.</span>集合不使用泛型，默认就是Object，可以存储任意的数据类型；但是不安全</span><br><span class="line">		<span class="number">2.</span>避免了向上向下类型的转化，</span><br><span class="line">		<span class="number">3.</span>把运行期的异常提到了编译期</span><br><span class="line">		</span><br><span class="line">	定义和使用含有泛型的类，方法，</span><br><span class="line">		含有泛型的方法，再调用方法的时候确定泛型</span><br><span class="line">		传递什么类型的参数，泛型就是什么</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">classfanxing</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> E name;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">          <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">          	System.out.println(e);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">static</span> &lt;N&gt; <span class="function"><span class="keyword">void</span> <span class="title">methods</span><span class="params">(N n)</span></span>&#123;</span><br><span class="line">          	System.out.println(n);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          泛型接口</span><br><span class="line">          	第一种</span><br><span class="line">          	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fanxingimpl</span> <span class="keyword">implements</span> <span class="title">fanxing22</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">            	<span class="meta">@Override</span></span><br><span class="line">           		 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            第二种 </span><br><span class="line">            	接口使用什么泛型，实现类就因该是什么泛型，类跟着接口走</span><br><span class="line">            	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fanxingimpl</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">fanxing22</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            	</span><br><span class="line">          </span><br><span class="line">         泛型通配符</span><br><span class="line">         	不知道使用什么类型来接受的时候，可以使用 ？ 表示未知通配符</span><br><span class="line">         	此时只能接收数据，不能往集合中传递数据</span><br><span class="line">         	泛型是没有继承概念的</span><br></pre></td></tr></table></figure>

<h2 id="11-8数据结构"><a href="#11-8数据结构" class="headerlink" title="11.8数据结构"></a>11.8数据结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">栈  </span><br><span class="line">	先进后出 压栈  弹栈   进<span class="number">123</span>   出<span class="number">321</span></span><br><span class="line">队列</span><br><span class="line">	先进先出  进<span class="number">123</span>   出<span class="number">123</span></span><br><span class="line">数组</span><br><span class="line">	查询快，增删慢  因为数组的地址是连续的；慢是因为数组的长度是固定的</span><br><span class="line">链表</span><br><span class="line">	查询慢，增删快	地址不是连续的，每次查询从头开始；快是因为堆整体结构没有影响</span><br><span class="line">		一个节点分为三部分  存储前一个节点地址，一个存储数据，一个存储后一个节点</span><br><span class="line">	单项链表  不能保证顺序</span><br><span class="line">	双向链表	一个存储顺序，另外一个是一个有序的集合</span><br><span class="line">红黑树</span><br><span class="line">		二叉树上面</span><br><span class="line">	排序树</span><br><span class="line">		 左子树小，右子树大</span><br><span class="line">		 </span><br><span class="line">	平衡树</span><br><span class="line">		左孩子，右孩子相等</span><br><span class="line">	不平衡树</span><br><span class="line">		左孩子不等于右孩子</span><br><span class="line">	红黑树</span><br><span class="line">		趋近于平衡树，查询速度快，查询叶子节点最大次数和最小次数不能超过二倍</span><br><span class="line">		约束条件</span><br><span class="line">			<span class="number">1.</span>节点可以是红色或者黑色</span><br><span class="line">			<span class="number">2.</span>根节点是黑色</span><br><span class="line">			<span class="number">3.</span>叶子节点是黑色的</span><br><span class="line">			<span class="number">4.</span>每个红色节点的子节点都是黑色的</span><br><span class="line">			<span class="number">5.</span>任何一个节点到其每一个叶子节点的路径上的所有黑色节点相同</span><br></pre></td></tr></table></figure>

<h2 id="11-9-List"><a href="#11-9-List" class="headerlink" title="11.9 List"></a>11.9 List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>有序的集合  存储 <span class="number">123</span>  取值 <span class="number">123</span></span><br><span class="line"><span class="number">2.</span>有索引，包含了一些带索引的方法</span><br><span class="line"><span class="number">3.</span>允许存储重复的元素</span><br></pre></td></tr></table></figure>

<h2 id="11-10-linkedList"><a href="#11-10-linkedList" class="headerlink" title="11.10 linkedList"></a>11.10 linkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一个双向链表，是一个链表结构，查询慢，增删快；多线程</span><br><span class="line">有大量操作首位元素的方法</span><br><span class="line">不能使用多态</span><br></pre></td></tr></table></figure>

<h2 id="11-11-Vector"><a href="#11-11-Vector" class="headerlink" title="11.11 Vector"></a>11.11 Vector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层结构也是一个数组，单线程</span><br></pre></td></tr></table></figure>

<h2 id="11-12-HashSet"><a href="#11-12-HashSet" class="headerlink" title="11.12 HashSet"></a>11.12 HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>哈希表结构</span><br><span class="line"><span class="number">2.</span>没有顺序，无序结构</span><br><span class="line"><span class="number">3.</span>没有索引，没有带索引的方法</span><br><span class="line"><span class="number">4.</span>存储和取出的速度不一样，是一个无序的集合</span><br><span class="line"><span class="number">5.</span>查询的速度比较快</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要让哈希表存储不重复的元素，就必须重写hasCode和equals方法</span></span><br><span class="line">	哈希值</span><br><span class="line">		是一个十进制的整数，有系统随机给出，是一个模拟逻辑地址</span><br><span class="line">		Object下面有一个方法，可以获取哈希值</span><br><span class="line">		<span class="keyword">native</span> 是代表该方法调用本地操作系统的方法</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	哈希表</span><br><span class="line">		！！！就是数组加链表或者数组加红黑树</span><br><span class="line">		</span><br><span class="line">		把元素进行了分组，哈希值相同的元素是同一组，链表红黑树把哈希值相同的元素存到一起</span><br><span class="line">		如果链表的长度超过了<span class="number">8</span>为，那么就会把链表转化为红黑树 提高查询速度</span><br><span class="line">		先计算哈希值，然后存储会调用 equals方法</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	使用 HashSet 来存储自定义元素，</span><br><span class="line">		所以需要重写 hascode方法  和  equals方法</span><br></pre></td></tr></table></figure>

<h2 id="11-13-linkedHashSet"><a href="#11-13-linkedHashSet" class="headerlink" title="11.13 linkedHashSet"></a>11.13 linkedHashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">底层是一个哈希表  和 链表  多了一条链表  用来记录元素的存储顺序</span><br><span class="line"></span><br><span class="line">相比HashSet  是一个有序的集合</span><br></pre></td></tr></table></figure>

<h2 id="11-14-集合工具类的方法"><a href="#11-14-集合工具类的方法" class="headerlink" title="11.14 集合工具类的方法"></a>11.14 集合工具类的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collections.addAll(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>);  往集合中添加多个元素</span><br><span class="line">Collections.shuffle(list)    打乱集合</span><br><span class="line">Collections.sort(list)   排序 从小到大  注意 只能是 list接口的实现类</span><br><span class="line">		这个方法 自定义类使用前提 必须重写接口 comparable 方法</span><br><span class="line">			<span class="keyword">this</span>.getAge() - O.getAge()   按照年龄升序</span><br><span class="line">		comprator</span><br><span class="line">			Collections.sort(list,<span class="keyword">new</span> comprator&lt;Integer&gt;&#123;</span><br><span class="line">                <span class="comment">//重写比较规则</span></span><br><span class="line">			&#125;)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		可以组合排序 设置第二个排序的字段</span><br></pre></td></tr></table></figure>

<h2 id="11-15-Map集合"><a href="#11-15-Map集合" class="headerlink" title="11.15 Map集合"></a>11.15 Map集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">每一个元素包含两个值，也叫做双列集合</span><br><span class="line">	键值对</span><br><span class="line">		<span class="number">1.</span>键不能重复，值可以重复</span><br><span class="line">		<span class="number">2.</span>key 和 value 的数据类型可以相同也可以不同</span><br><span class="line">		<span class="number">3.</span>key 和 value 是一一对应的 </span><br><span class="line">		</span><br><span class="line">		Hashmap集合</span><br><span class="line">			<span class="number">1.</span>底层是哈希表，查询速度特别快</span><br><span class="line">			<span class="number">2.</span>是一个无序的集合，存储和取出元素的顺序不一致</span><br><span class="line">		linkedhashmap的特点</span><br><span class="line">			<span class="number">1.</span>底层是哈希表加链表</span><br><span class="line">			<span class="number">2.</span>是一个有序的集合，保证迭代的顺序</span><br><span class="line">			</span><br><span class="line">	常用方法</span><br><span class="line">		put(key,value)</span><br><span class="line">		get()</span><br><span class="line">		remove()</span><br><span class="line">		containskey()   判断是否包含 key</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		遍历</span><br><span class="line">			keyset()</span><br><span class="line">				把map集合中的所有的key取出来存储到Set()集合中</span><br><span class="line">				使用迭代器/增强<span class="keyword">for</span>循环来遍历，获取到每一个key</span><br><span class="line">				然后通过get(key)获取值</span><br><span class="line">			entryset()</span><br><span class="line">				在map中有一个内部接口 entry，</span><br><span class="line">				当map集合创建的时候，就会在map集合中创建一个entry对象，用来记录键和值</span><br><span class="line">				</span><br><span class="line">				遍历的时候会把map内部的多个entry对象取出来，存储到一个Set集合中，遍历set</span><br><span class="line">				然后使用 entry的  getkey()  getvalue();</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			存储自定义类键值对</span><br></pre></td></tr></table></figure>

<h2 id="11-16-linkedhashmap"><a href="#11-16-linkedhashmap" class="headerlink" title="11.16 linkedhashmap"></a>11.16 linkedhashmap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">底层原理</span><br><span class="line">	哈希表 + 链表</span><br><span class="line">	可以保证顺序，存储顺序一致</span><br></pre></td></tr></table></figure>

<h2 id="11-17-hashtable"><a href="#11-17-hashtable" class="headerlink" title="11.17 hashtable"></a>11.17 hashtable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">是一个个哈希表</span><br><span class="line">	<span class="number">1.</span>不能存储  空对象  <span class="keyword">null</span></span><br><span class="line">	<span class="number">2.</span>单线程同步，是一个安全的集合</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	properties集合是他的子类</span><br></pre></td></tr></table></figure>

<h2 id="11-18-jdk9-新增对集合"><a href="#11-18-jdk9-新增对集合" class="headerlink" title="11.18 jdk9 新增对集合"></a>11.18 jdk9 新增对集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">新增了一个 静态的方法  of，可以给集合一次性添加多个元素</span><br><span class="line"><span class="number">1.</span>of方法只适用于  List,Map,Set接口，不适用于接口的实现类</span><br><span class="line"><span class="number">2.</span>of方法的返回值是一个不能改变的集合</span><br><span class="line"><span class="number">3.</span>Set接口和map接口在调用 of 方法的时候，不能有重复的元素</span><br><span class="line"></span><br><span class="line">	List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e“);</span></span><br></pre></td></tr></table></figure>



<h1 id="十二-字符串"><a href="#十二-字符串" class="headerlink" title="十二.字符串"></a>十二.字符串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字符串的特点</span><br><span class="line">	<span class="number">1.</span>字符串的内容不可改变</span><br><span class="line">	<span class="number">2.</span>正因为字符串的内容不可以改变，所以字符串是可以共享使用的</span><br><span class="line">	<span class="number">3.</span>字符串效果上是相当于<span class="keyword">char</span>[]字符数组，但是底层原理是字节数组<span class="keyword">byte</span>	[]</span><br></pre></td></tr></table></figure>

<h2 id="12-1创建字符串"><a href="#12-1创建字符串" class="headerlink" title="12.1创建字符串"></a>12.1创建字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">三种构造方法</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span></span>; 创建一个空白字符串，不含有任何内容</span><br><span class="line">			String str = <span class="keyword">new</span> String();</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>; 根据字符数组的内容，来创建</span><br><span class="line">			<span class="keyword">char</span>[] charArray = &#123;‘A’,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;;</span><br><span class="line">			String str = <span class="keyword">new</span> String(charArray);</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] array)</span></span>; 根据字节数组的内容，来创建</span><br><span class="line">			<span class="keyword">byte</span>[] charArray = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">			String str = <span class="keyword">new</span> String(charArray);</span><br><span class="line">一种直接创建</span><br><span class="line">		String str = <span class="string">&quot;Hello&quot;</span>  直接写上，照样是字符串对象</span><br></pre></td></tr></table></figure>

<h2 id="12-2字符串的常量池"><a href="#12-2字符串的常量池" class="headerlink" title="12.2字符串的常量池"></a>12.2字符串的常量池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">！！！！在堆当中</span><br><span class="line">程序当中直接写上的双引号字符串，就在常量池中；</span><br><span class="line">对于基本数据类型，是值的比较</span><br><span class="line">引用类型来说 是地址的比较 </span><br></pre></td></tr></table></figure>

<h2 id="12-3字符串的方法"><a href="#12-3字符串的方法" class="headerlink" title="12.3字符串的方法"></a>12.3字符串的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">str1.equals(str2);   比较两个值是不是一样  只有参数是一个字符串并且值相等才会相同</span><br><span class="line">	注意事项 <span class="number">1.</span>具有对称性  a,b互相比较一样</span><br><span class="line">			<span class="number">2.</span>常量变量  <span class="string">&quot;hello&quot;</span>.equals(a); 推荐  反过来会报错</span><br><span class="line">str1.equalsIgnoreCase(str2)  忽略大小写 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str1.length();  返回字符串的长度；</span><br><span class="line">str1.concat(str2);  将两个字符串拼接并且返回新的字符串；</span><br><span class="line">str1.charAt(<span class="number">1</span>)  返回索引位置的单个字符；</span><br><span class="line">str1.indexOf(<span class="string">&#x27;a&#x27;</span>),查找小字符串在本来字符串当中的第一次的索引位置 </span><br><span class="line"></span><br><span class="line">字符串的截取方法</span><br><span class="line">str1.substring(index);  截取参数位置到结束位置</span><br><span class="line">str1.substring(a,b);	截取 a,b中间的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">转化：：：</span><br><span class="line">str1.toCharArray();  将当前字符串拆分成为字符数组的返回值；</span><br><span class="line">str1.getBytes(); 获取当前字符串的底层字节数组；</span><br><span class="line">str1.replace(old,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">分割：：：</span><br><span class="line">str1.split(regex); 按照参数的规则，将字符串分成若干部分；返回一个数组；</span><br><span class="line">注意事项 如果按照英文 .  进行分割，那么需要“\\.”才可以分割</span><br></pre></td></tr></table></figure>

<h1 id="十三-权限控制"><a href="#十三-权限控制" class="headerlink" title="十三.权限控制"></a>十三.权限控制</h1><h2 id="13-1-static"><a href="#13-1-static" class="headerlink" title="13.1 static"></a>13.1 static</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">静态关键字</span><br><span class="line">	一旦使用了<span class="keyword">static</span>关键字，那么这样的内容不再属于对象自己，而是属于类的，凡是本类的对象，dou共享同一份数据</span><br><span class="line">	</span><br><span class="line">	关键字 <span class="keyword">static</span>修饰成员变量的时候，</span><br><span class="line">		privat <span class="keyword">static</span> <span class="keyword">int</span> idCounter = <span class="number">0</span>;学号计数器</span><br><span class="line">		静态变量也可以通过对象名进行调用，也可以通过类名直接调用</span><br><span class="line">	修饰成员方法</span><br><span class="line">		静态方法：静态方法不属于对象，而是属于类的</span><br><span class="line">			对于静态方法来说，可以通过对象名进行调用，也可以通过类名直接调用</span><br><span class="line">			推荐用 类名进行调用</span><br><span class="line">			对于本类当中的静态方法，可以省略类名</span><br><span class="line">		注意方法：<span class="number">1.</span> 静态方法不能访问非静态</span><br><span class="line">					因为在内存里面现有的静态内容，然后有非静态内容</span><br><span class="line">				<span class="number">2.</span>静态方法中不能使用 <span class="keyword">this</span></span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">方法区里面有一个静态区 静态变量和静态方法在里面</span><br><span class="line"></span><br><span class="line">	静态代码快 </span><br><span class="line">		第一次用到本类是，静态代码块执行唯一的一次</span><br><span class="line">		静态代码快比构造方法先执行</span><br><span class="line">		<span class="keyword">static</span>&#123;</span><br><span class="line">            </span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-2-final"><a href="#13-2-final" class="headerlink" title="13.2 final"></a>13.2 final</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>可以用来修饰一个类</span><br><span class="line">	当前这个类不能有任何的子类，一定有父类  <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 名称  </span>&#123;&#125;；</span><br><span class="line">	其中所有的方法都不能覆盖重写</span><br><span class="line"><span class="number">2.</span>可以用来修饰一个方法</span><br><span class="line">	这个方法就是最终方法，不能被覆盖重写</span><br><span class="line">	对于类方法，不能同时使用 abstarct 和 <span class="keyword">final</span>；</span><br><span class="line"><span class="number">3.</span>可以用来修饰一个局部变量</span><br><span class="line">	一次赋值，终身不变</span><br><span class="line">	保证有唯一一次赋值</span><br><span class="line">	<span class="keyword">int</span> num; num = <span class="number">100</span>; 正确</span><br><span class="line">	对于基本数据类型来说，说的是值不变；</span><br><span class="line">	对于引用数据类型来说，说的是引用地址不变</span><br><span class="line"><span class="number">4.</span>可以用来修饰一个成员变量</span><br><span class="line">	这个声明变量不可变，但是成员变量具有默认值，这也算赋值，<span class="keyword">final</span>必须手动立马赋值</span><br></pre></td></tr></table></figure>

<h2 id="13-3四种权限修饰符"><a href="#13-3四种权限修饰符" class="headerlink" title="13.3四种权限修饰符"></a>13.3四种权限修饰符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">			<span class="keyword">public</span>   &gt;  <span class="keyword">protected</span> &gt; (<span class="keyword">default</span>)  &gt;  <span class="keyword">private</span></span><br><span class="line">同一个类 		Y          Y			Y			Y</span><br><span class="line">同一个包		Y			Y			Y			N</span><br><span class="line">不同包子类		Y			Y			N			N</span><br><span class="line">不同包非子类		Y			N			N			N</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="十四-interface"><a href="#十四-interface" class="headerlink" title="十四.interface"></a>十四.interface</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">接口就是多个类的公共规范</span><br><span class="line">	接口就是引用数据类型，最重要的就是抽象方法</span><br><span class="line">	</span><br><span class="line">	定义一个接口</span><br><span class="line">		如果是java7,接口可以包含 </span><br><span class="line">			<span class="number">1.</span>常量</span><br><span class="line">			<span class="number">2.</span>抽象方法</span><br><span class="line">		如果是java8，还可以包含</span><br><span class="line">			<span class="number">3.</span>默认方法</span><br><span class="line">			<span class="number">4.</span>静态方法</span><br><span class="line">        如果是java9,还可以包含</span><br><span class="line">        	<span class="number">5.</span>私有方法</span><br><span class="line">        	</span><br><span class="line">    </span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<h2 id="14-1接口抽象方法"><a href="#14-1接口抽象方法" class="headerlink" title="14.1接口抽象方法"></a>14.1接口抽象方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">接口注意事项</span><br><span class="line">    		<span class="number">1.</span>必须修饰符 有 <span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line">           <span class="number">2.</span>可以省略</span><br><span class="line">           </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">inerface</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methods</span><span class="params">()</span></span>;</span><br><span class="line">       &#125;</span><br><span class="line">       注意事项</span><br><span class="line">      <span class="number">1.</span>接口不能直接使用，必须有实现类来实现接口</span><br><span class="line">      <span class="number">2.</span>接口的实现类必须覆盖重写(实现)接口中的所有抽象方法，去掉<span class="keyword">abstract</span>，加上大括号</span><br><span class="line">      </span><br><span class="line">      抽象方法：：：：：</span><br><span class="line">      		<span class="comment">//        创建实现类的对象</span></span><br><span class="line">       	myInterface imp1 = <span class="keyword">new</span> myInterface();</span><br><span class="line">       	imp1.methods();</span><br></pre></td></tr></table></figure>

<h2 id="14-2接口默认方法"><a href="#14-2接口默认方法" class="headerlink" title="14.2接口默认方法"></a>14.2接口默认方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">默认方法：：：</span><br><span class="line">       	是为了解决接口升级的问题，比如新添加抽象类</span><br><span class="line">       	默认方法会被实现类继承下去</span><br><span class="line">       	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methods2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">  			 &#125;</span><br><span class="line">  			 可以直接调用，默认方法会被继承下去</span><br><span class="line">       	注意事项</span><br><span class="line">       		<span class="number">1.</span>接口的默认方法，可以通过接口实现类直接调用</span><br><span class="line">       		<span class="number">2.</span>接口的默认方法，也可以被接口实现类进行覆盖重写</span><br></pre></td></tr></table></figure>

<h2 id="14-3接口的静态方法"><a href="#14-3接口的静态方法" class="headerlink" title="14.3接口的静态方法"></a>14.3接口的静态方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简单定义</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="number">1.</span>不能用实现类对象调用接口当中的静态方法</span><br><span class="line">	<span class="number">2.</span>通过接口调用，直接调用静态方法</span><br><span class="line">	interface.methods();</span><br></pre></td></tr></table></figure>

<h2 id="14-4接口的私有方法"><a href="#14-4接口的私有方法" class="headerlink" title="14.4接口的私有方法"></a>14.4接口的私有方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">问题描述，解决重复代码的问题，不应该让实现类使用，应该实现私有化</span><br><span class="line"><span class="number">1.</span>普通私有方法 解决多个默认方法之间的重复代码问题</span><br><span class="line">	<span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"><span class="number">2.</span>静态私有方法	解决多个静态方法之间重复代码问题</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-5接口的常量的定义和使用"><a href="#14-5接口的常量的定义和使用" class="headerlink" title="14.5接口的常量的定义和使用"></a>14.5接口的常量的定义和使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">接口当中也可以定义 ‘成员变量’，而且必须由三个关键字修饰 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span></span><br><span class="line">	一旦使用<span class="keyword">final</span>变量，那就不能改变</span><br><span class="line">	<span class="number">1.</span>可以省略这三个关键字，但是照样是这样；</span><br><span class="line">	<span class="number">2.</span>接口当中的常量，必须进行赋值，不能不赋值；</span><br><span class="line">	<span class="number">3.</span>不能变的常量，尽量使用大写</span><br></pre></td></tr></table></figure>

<h2 id="14-6继承父类并且实现多个接口"><a href="#14-6继承父类并且实现多个接口" class="headerlink" title="14.6继承父类并且实现多个接口"></a>14.6继承父类并且实现多个接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>接口是没有静态代码块或者构造方法的</span><br><span class="line"><span class="number">2.</span>一个类的父类是唯一的，但是一个类可以实现多个接口</span><br><span class="line"><span class="number">3.</span>如果实现类中的多个接口中，存在相同的抽象方法，重写即可，；</span><br><span class="line"><span class="number">4.</span>如果实现类中没有实现重写覆盖所有接口的所有抽象方法，那么实现类必须是一个抽象类</span><br><span class="line"><span class="number">5.</span>如果实现类实现的多个接口中，存在重复的默认方法，这种情况下一定要进行覆盖重写</span><br><span class="line"><span class="number">6.</span>优先级：一个类直接父类的方法和接口中的默认方法，产生了冲突，会优先用父类中的方法</span><br></pre></td></tr></table></figure>

<h2 id="14-7接口之间的多继承"><a href="#14-7接口之间的多继承" class="headerlink" title="14.7接口之间的多继承"></a>14.7接口之间的多继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>类和类之间是单继承的，直接父类只有一个</span><br><span class="line"><span class="number">2.</span>类与接口是多实现的，一个类可以实现多个接口</span><br><span class="line"><span class="number">3.</span>接口和接口之间是多继承的</span><br><span class="line">	接口可以继承接口；</span><br><span class="line">	如果接口继承的父接口的抽象方法重复，没关系</span><br><span class="line">	如果接口继承的父接口的默认方法重复，有关系，子接口必须进行父接口默认方法的重新，带defult</span><br></pre></td></tr></table></figure>

<h2 id="14-8-面向对象三大特性-多态"><a href="#14-8-面向对象三大特性-多态" class="headerlink" title="14.8 面向对象三大特性 多态"></a>14.8 面向对象三大特性 多态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">extends继承和 implements实现，是多态性的前提</span><br><span class="line"><span class="number">1</span>，需要有继承关系的存在。</span><br><span class="line"><span class="number">2</span>，需要有方法的重写。</span><br><span class="line"><span class="number">3</span>，需要有父类的引用指向子类对象。</span><br><span class="line">	</span><br><span class="line">	一个对象有多种形态，这就是对象的多态性</span><br><span class="line">	代码体现多态性， 父类引用指向子类对象</span><br><span class="line">	</span><br><span class="line">	父类名称 对象名 = <span class="keyword">new</span> 子类名称();</span><br><span class="line">	接口名称 对象名 = <span class="keyword">new</span> 实现类名称();</span><br><span class="line">	</span><br><span class="line">	方法</span><br><span class="line">	可以调用子类父类的方法</span><br><span class="line">		！！！！同一个方法，看等号右边</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	成员变量</span><br><span class="line">		<span class="number">1.</span>直接通过对象名称访问成员变量，看等号左边是谁，谁就优先，没有那就想上找</span><br><span class="line">		<span class="number">2.</span>间接通过成员方法调用</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	成员方法</span><br><span class="line">		<span class="number">1.</span>看<span class="keyword">new</span>是谁，没有那就想上找父类</span><br><span class="line">		<span class="number">2.</span>编译看左边，运行看右边</span><br><span class="line">		</span><br><span class="line">	当超类类变量引用子类对象</span><br><span class="line">				访问成员变量时：访问的是父类的成员变量</span><br><span class="line">				访问成员方法时：先访问的是超类的此方法，如果此方法被子类覆盖，则调用子类的方法。并且不能访问子类特有的方法</span><br></pre></td></tr></table></figure>

<h2 id="14-9使用多态的好处"><a href="#14-9使用多态的好处" class="headerlink" title="14.9使用多态的好处"></a>14.9使用多态的好处</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用了多态，等号左边统一，</span><br><span class="line">无论右边换成那个子对象，等号左边的调用方法不会变化</span><br></pre></td></tr></table></figure>

<h2 id="14-11向上转型和向下转型"><a href="#14-11向上转型和向下转型" class="headerlink" title="14.11向上转型和向下转型"></a>14.11向上转型和向下转型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">向上转型</span><br><span class="line">	其实就是多态写法，创建一个子类对象，当作一个父类来看待使用；</span><br><span class="line"></span><br><span class="line">	注意事项： 向上转型一定是安全的 小范围转向了大范围；</span><br><span class="line">			一但向上转型为父类，那么就无法调用子类原本特有的内容</span><br><span class="line">向下转型</span><br><span class="line">	其实是一个还原动作</span><br><span class="line">		子类名称 对象名 = （子类名称）父类对象；</span><br><span class="line">	将父类对象还原为原来的子类对象</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Cat();  向上转型</span><br><span class="line">		Cat cat = (Cat) animal;		向下转型</span><br><span class="line">		</span><br><span class="line">		注意事项</span><br><span class="line">			<span class="number">1.</span>必须保证对象本来创建的时候是猫，才能向下转型为猫</span><br><span class="line">			<span class="number">2.</span>如果不是那么就会报错</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">判断一个父类引用的对象，本来是什么子类</span><br><span class="line">	instance</span><br><span class="line">		对象 <span class="keyword">instanceof</span> 类型 ：会得到到Boolean判断，</span><br><span class="line">		animal <span class="keyword">instanceof</span> Dog	<span class="keyword">false</span></span><br><span class="line">		animal <span class="keyword">instanceof</span> Cat  <span class="keyword">true</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	实现计算机 键盘 鼠标 接口USB</span><br><span class="line">		  Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">                computer.powerOn();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        创建完毕计算机，准备鼠标键盘</span></span><br><span class="line">                mouse ms = <span class="keyword">new</span> mouse();</span><br><span class="line">                <span class="comment">/*向上转型*/</span></span><br><span class="line">                Usb usbmouse = <span class="keyword">new</span> mouse();</span><br><span class="line">                computer.useDevice(usbmouse);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建一个usb键盘</span></span><br><span class="line">                keyboard kb = <span class="keyword">new</span> keyboard();</span><br><span class="line">                computer.useDevice(kb);<span class="comment">//这里发生了向上转型</span></span><br><span class="line"></span><br><span class="line">                computer.powerOff();</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useDevice</span><span class="params">(Usb usb)</span></span>&#123;</span><br><span class="line">                    usb.open();</span><br><span class="line">                    <span class="keyword">if</span>(usb <span class="keyword">instanceof</span> mouse)&#123;</span><br><span class="line">                        mouse ms = (mouse) usb;</span><br><span class="line">                        ms.click();</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (usb <span class="keyword">instanceof</span> keyboard)&#123;</span><br><span class="line">                        keyboard kb = (keyboard) usb;</span><br><span class="line">                        kb.input();</span><br><span class="line">                    &#125;</span><br><span class="line">                    usb.close();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<h1 id="十五-内部类"><a href="#十五-内部类" class="headerlink" title="十五.内部类"></a>十五.内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果一个事物包含另外一个事物，那么就是一个类包含另外一个类</span><br><span class="line"></span><br><span class="line">分类 <span class="number">1.</span>成员内部类</span><br><span class="line">	<span class="number">2.</span>局部内部类（包含匿名内部类）</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h2 id="15-1成员内部类"><a href="#15-1成员内部类" class="headerlink" title="15.1成员内部类"></a>15.1成员内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">内部类</span><br><span class="line">		修饰符 <span class="class"><span class="keyword">class</span> <span class="title">body</span></span>&#123;  <span class="comment">//外部类</span></span><br><span class="line">            修饰符 <span class="class"><span class="keyword">class</span> <span class="title">heart</span></span>&#123;  <span class="comment">//成员内部类</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heart</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	如何使用成员内部类？</span><br><span class="line">		<span class="number">1.</span>间接方法：在外部类的方法中，使用内部类，然后main只是调用外部类的方法</span><br><span class="line">			在外部类的方法中，</span><br><span class="line">				<span class="keyword">new</span> heart().beat();</span><br><span class="line">				通过外部类对象，调用外部类方法，里面间接使用内部类Heart</span><br><span class="line">		<span class="number">2.</span>直接调用	外部类名称.内部类名称  对象名 = <span class="keyword">new</span> 外部类名称().new 内部类名称()</span><br><span class="line">			body.heart  ht = <span class="keyword">new</span> body().new heart</span><br><span class="line">			</span><br><span class="line">		访问变量</span><br><span class="line">			内部类的方法局部变量 直接  num</span><br><span class="line">			内部类的成员变量   <span class="keyword">this</span>.num;</span><br><span class="line">			外部类的成员变量   外部类名.<span class="keyword">this</span>.num;</span><br></pre></td></tr></table></figure>

<h2 id="15-2-局部内部类"><a href="#15-2-局部内部类" class="headerlink" title="15.2 局部内部类"></a>15.2 局部内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如果一个类是定义在一个成员方法内部的，那就是一个局部内部类</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">heart</span>()</span>&#123; <span class="comment">//局部内部类</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	调用局部内部类的方法，在方法内部使用 <span class="keyword">new</span> 创建一个对象，然后这个对象调用方法；</span><br><span class="line">	主函数调用外部方法；</span><br><span class="line">	</span><br><span class="line">	注意事项 ：</span><br><span class="line">			<span class="number">1.</span>外部类		<span class="keyword">public</span>/<span class="keyword">default</span></span><br><span class="line">			<span class="number">2.</span>外部内部类		四种修饰符都可以</span><br><span class="line">			<span class="number">3.</span>局部内部类  	什么都不能写</span><br><span class="line">			</span><br><span class="line">			如果希望访问所在方法的局部变量，那么这个局部变量必须是 有效 <span class="keyword">final</span>的</span><br><span class="line">			原因是因为 </span><br><span class="line">				<span class="class"><span class="keyword">class</span>对象的生命周期比方法的成员变量的生命周期更加长</span></span><br></pre></td></tr></table></figure>

<h2 id="15-3匿名内部类"><a href="#15-3匿名内部类" class="headerlink" title="15.3匿名内部类"></a>15.3匿名内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果接口的实现类(或者父类的子类)只需要使用唯一的一次；</span><br><span class="line">那么这种情况下就可以省略掉 该类的定义，而改为使用  匿名内部类</span><br><span class="line"></span><br><span class="line">	定义格式</span><br><span class="line">		接口名称 对象名 = <span class="keyword">new</span> 接口名称()&#123;</span><br><span class="line">            <span class="comment">//覆盖重写所有的接口方法</span></span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	注意事项</span><br><span class="line">		<span class="number">1.</span>匿名内部类在创建对象的时候只能使用唯一一次</span><br><span class="line">		<span class="number">2.</span>如果省略了对象名称 直接 <span class="keyword">new</span>  ，就只能调用一次</span><br></pre></td></tr></table></figure>

<h2 id="15-4类，接口作为成员变量类型"><a href="#15-4类，接口作为成员变量类型" class="headerlink" title="15.4类，接口作为成员变量类型"></a>15.4类，接口作为成员变量类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以把匿名内部类 类对象，接口实现 传入 函数方法里面</span><br><span class="line">也可以当作返回值 参数</span><br></pre></td></tr></table></figure>

<h1 id="十六-时间日期类"><a href="#十六-时间日期类" class="headerlink" title="十六.时间日期类"></a>十六.时间日期类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date</span><br><span class="line">	构造方法</span><br><span class="line">		System.cunrrentTimeMillis()  计算时间原点到现在经历了多少毫秒</span><br><span class="line">		Date date = <span class="keyword">new</span> date();</span><br><span class="line">		Date date = <span class="keyword">new</span> date(<span class="keyword">long</span> date);</span><br><span class="line">	成员方法</span><br><span class="line">		getTime()当前日期转化为毫秒</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="16-1-DateFormat类"><a href="#16-1-DateFormat类" class="headerlink" title="16.1 DateFormat类"></a>16.1 DateFormat类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.text.Dateformat</span><br><span class="line">	返回指定格式日期</span><br><span class="line">		SimpleDateformate sdf = <span class="keyword">new</span> SimpleDateformate(<span class="string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)</span><br><span class="line">		Date date = <span class="keyword">new</span> Date();</span><br><span class="line">		sdf.format(date)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h2 id="16-1-Calendar类"><a href="#16-1-Calendar类" class="headerlink" title="16.1 Calendar类"></a>16.1 Calendar类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Canlendar.getinstance();</span><br><span class="line"></span><br><span class="line">	c.get()返回给定日历的字段</span><br><span class="line">	c.set()给指定的日历字段设置值</span><br><span class="line">	c.add() 增加日期</span><br></pre></td></tr></table></figure>

<h2 id="16-2-System类"><a href="#16-2-System类" class="headerlink" title="16.2 System类"></a>16.2 System类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> currentTimeMillis() 返回以毫秒为单位的当前时间</span><br><span class="line"><span class="number">2.</span> arraycopy() 将数组中指定的数据拷贝到另外一个数组里面</span><br></pre></td></tr></table></figure>

<h2 id="16-3-StringBuilder类"><a href="#16-3-StringBuilder类" class="headerlink" title="16.3 StringBuilder类"></a>16.3 StringBuilder类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字符串的相加，内存就有多个字符串，效率低下</span><br><span class="line">	字符串缓冲区： 提高字符串的操作效率</span><br><span class="line">				可以看作一个长度变化的字符串；底层没有<span class="keyword">final</span>修饰</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">	append()  添加任意数据类型的字符串形式，并且返回当前对象自身  可以链式操作</span><br><span class="line">	tostring()  将stringBuilder 转化为  Strin对象</span><br></pre></td></tr></table></figure>

<h1 id="十七-异常"><a href="#十七-异常" class="headerlink" title="十七.异常"></a>十七.异常</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">语法不是语法错误，</span><br><span class="line">throwable</span><br><span class="line">		<span class="number">1.</span>error  错误</span><br><span class="line">			非常严重</span><br><span class="line">		<span class="number">2.</span>exception  异常  编译器异常</span><br><span class="line">			runtimeexception 运行期异常</span><br><span class="line">		</span><br><span class="line">		<span class="number">1.</span>抛出异常</span><br><span class="line">				虚拟机执行，中断程序</span><br><span class="line">		<span class="number">2.</span><span class="keyword">try</span> <span class="keyword">catch</span></span><br><span class="line">				抛出数组，后面代码继续执行</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">            可能会出现异常的代码</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            出现异常解决</span><br><span class="line">            sout  e</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		jvm会检测出程序的异常</span><br><span class="line">			<span class="number">1.</span>会根据异常产生的原因创建一个异常对象，这个对象包含个原因，内容，位置</span><br><span class="line">			<span class="number">2.</span>在方法中没有异常处理逻辑，那么jvm就会把异常对象抛出给方法的调用者Main 来处理</span><br><span class="line">			<span class="number">3.</span>main收到异常对象，但是也没有处理机制，就会给jvm处理<span class="number">4</span></span><br><span class="line">			<span class="number">4.</span>jvm会把异常对象打印在控制台，终止当前的运行程序</span><br></pre></td></tr></table></figure>

<h2 id="17-1-throw"><a href="#17-1-throw" class="headerlink" title="17.1 throw"></a>17.1 throw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">使用格式</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;异常产生的原因”);</span></span><br><span class="line"><span class="string">注意</span></span><br><span class="line"><span class="string">	1.throw 必须写在方法的内部</span></span><br><span class="line"><span class="string">	2.throw 关键字后面的对象必须是Exception或者他的子类对象</span></span><br><span class="line"><span class="string">	3.我们必须处理这个对象</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	例如</span></span><br><span class="line"><span class="string">		if(arr ==null)&#123;</span></span><br><span class="line"><span class="string">            throw new nullpointerexception(“传递的数组是空”)</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">		非空判断</span></span><br><span class="line"><span class="string">			Object.requireNonnull(obj)  判断空指针异常</span></span><br></pre></td></tr></table></figure>

<h2 id="17-2-throws"><a href="#17-2-throws" class="headerlink" title="17.2 throws"></a>17.2 throws</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">异常处理的第一种方法</span><br><span class="line">	</span><br><span class="line">	注意事项 <span class="number">1.</span>必须写在方法声明处</span><br><span class="line">			<span class="number">2.</span>声明的异常必须是 Exception或者Exception的子类</span><br><span class="line">			<span class="number">3.</span>如果方法内部抛出了多个异常，<span class="keyword">throws</span>必须声明多个异常</span><br><span class="line">				如果抛出多个异常对象有子类父类关系，直接交给父类</span><br><span class="line">			<span class="number">4.</span>调用了一个声明抛出异常的方法，必须处理</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			方法  <span class="keyword">throws</span> 异常类型&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> 异常类型</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-3-try-catch"><a href="#17-3-try-catch" class="headerlink" title="17.3 try catch"></a>17.3 try catch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">           可能会出现异常的代码</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//定义一个变量接受异常对象</span></span><br><span class="line">           出现异常解决</span><br><span class="line">           sout  e</span><br><span class="line">           <span class="comment">//一般异常会记录到一个日志中</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">1.</span><span class="keyword">try</span>会抛出多个异常，那么就可以使用多个<span class="keyword">catch</span>来处理这些异常</span><br><span class="line"><span class="number">2.</span>如果<span class="keyword">try</span>中产生了异常，就会执行<span class="keyword">catch</span>的异常处理逻辑</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">throwable定义了三个异常处理的方法</span><br><span class="line">	e.getmessage() 返回详细消息字符串</span><br><span class="line">	e.tostring()	返回简短描述</span><br><span class="line">	e.printstacktrace()  jvm打印对象，最详细</span><br></pre></td></tr></table></figure>

<h2 id="17-4-final代码快"><a href="#17-4-final代码快" class="headerlink" title="17.4 final代码快"></a>17.4 final代码快</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果有一些代码 无论是否发生异常，都需要执行，一定会执行</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	注意事项  <span class="number">1.</span>不能单独处理</span><br><span class="line">			<span class="number">2.</span>一般用于资源释放，无论资源是否异常，都要资源释放(IO)</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">finally</span>不要写 <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="17-5多异常处理"><a href="#17-5多异常处理" class="headerlink" title="17.5多异常处理"></a>17.5多异常处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>多个异常，多次捕获，分别处理</span><br><span class="line">		一个异常一个<span class="keyword">try</span> <span class="keyword">catch</span></span><br><span class="line"><span class="number">2.</span>多个异常，一次捕获，多次处理</span><br><span class="line">		写一个<span class="keyword">try</span> 多个<span class="keyword">catch</span></span><br><span class="line">		</span><br><span class="line">		注意一场变量如果有子父类关系，子类必须在上面</span><br><span class="line"><span class="number">3.</span> 多次异常一次捕获，一次处理</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	子父类异常</span><br><span class="line">		<span class="number">1.</span>如果父类抛出了多个异常，子类重写父类方法时候，抛出和父类相同的异常或者是父类异常的子类或者不抛出异常</span><br><span class="line">		<span class="number">2.</span>父类没有抛出异常，子类重写父类该方法时候也不能抛出异常，此时</span><br><span class="line">			子类异常，只能捕获处理，不能声明抛出</span><br></pre></td></tr></table></figure>

<h2 id="17-6自定义异常类"><a href="#17-6自定义异常类" class="headerlink" title="17.6自定义异常类"></a>17.6自定义异常类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxException</span> <span class="keyword">extends</span> <span class="title">Exception</span>/<span class="title">runtimeException</span></span>&#123;</span><br><span class="line">        添加一个空的构造方法</span><br><span class="line">        添加一个带异常信息的构造方法</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="十八-多线程"><a href="#十八-多线程" class="headerlink" title="十八.多线程"></a>十八.多线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">并发和并行</span><br><span class="line">	并发：指的是两个或者多个时间在同一个时间段发生，交替执行</span><br><span class="line">	并行：指的是两个或者多个事件在同一时刻发生，</span><br><span class="line">	</span><br><span class="line">线程进程</span><br><span class="line">	线程 线程是进程的执行单元，一个进程至少有一个线程，应用程序到cpu的路径</span><br><span class="line">	进程 一个内存中运行的程序，进入到内润的叫进程</span><br><span class="line">	</span><br><span class="line">线程调度</span><br><span class="line">	分时调度</span><br><span class="line">		所有线程轮流使用CPU的使用权，平均分配每一个线程占用的cpu时间</span><br><span class="line">	抢占式调度</span><br><span class="line">		优先让优先级高的线程使用cpu，如果优先级相同，会随机选择一个(线程随机性)，java为抢占式调度；</span><br><span class="line">		线程的优先级可以设置</span><br></pre></td></tr></table></figure>

<h2 id="18-1主线程，多线程"><a href="#18-1主线程，多线程" class="headerlink" title="18.1主线程，多线程"></a>18.1主线程，多线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">主线程：执行主线程的程序</span><br><span class="line">单线程程序 java只有一个单线程</span><br><span class="line">从main开始执行</span><br><span class="line">	</span><br><span class="line">	Thread类</span><br><span class="line">		<span class="number">1.</span>创建一个他的子类，</span><br><span class="line">		<span class="number">2.</span>在这个类中重写 run 方法，设置线程任务</span><br><span class="line">		<span class="number">3.</span>创建thread类的子对象</span><br><span class="line">		<span class="number">4.</span>调用类中的方法  start，开启新的线程</span><br><span class="line">			多次启动一个线程是非法的，特别是当线程已经结束之后，不能在重新执行</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">	获取当前执行的线程  Thread.currentThread()</span><br><span class="line">	</span><br><span class="line">	设置线程的方法</span><br><span class="line">		<span class="number">1.</span>thread类中的 setname();</span><br><span class="line">		<span class="number">2.</span>创建一个带参数的构造方法，调用父类的  <span class="keyword">super</span>方法，让父亲给自己起名</span><br><span class="line">		</span><br><span class="line">		thread.sleep() 让程序休眠一会，然后执行</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h2 id="18-2多线程的创建"><a href="#18-2多线程的创建" class="headerlink" title="18.2多线程的创建"></a>18.2多线程的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一种创建线程的方法		</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">duoxiancheng</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;run&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    第二种创建线程的方法</span><br><span class="line">       <span class="number">1.</span>创建一个runable接口实现类</span><br><span class="line">       <span class="number">2.</span>在实现类中重写 runable方法  run方法</span><br><span class="line">       <span class="number">3.</span>创建一个runable接口实现类对象</span><br><span class="line">       <span class="number">4.</span>创建 thread 类 对象，构造方法中传递 runable 接口的实现类对象</span><br><span class="line">       <span class="number">5.</span>调用thread类中的 start方法</span><br><span class="line">       </span><br><span class="line">       	runable接口，接口实现对象</span><br><span class="line">       		 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span> ; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;main: &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         runable接口的好处</span><br><span class="line">         	<span class="number">1.</span>一个类只能继承一个类，runable接口，还可以继承其他类</span><br><span class="line">         	<span class="number">2.</span>增强了程序的扩展性，降低了程序的耦合性</span><br><span class="line">            </span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h2 id="18-3匿名内部类实现多线程的创建"><a href="#18-3匿名内部类实现多线程的创建" class="headerlink" title="18.3匿名内部类实现多线程的创建"></a>18.3匿名内部类实现多线程的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">第一种</span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;zi线程&quot;</span>+ i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span> ; i++) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;main: &quot;</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      第二种</span><br><span class="line">      <span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">20</span> ; i++) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;zi线程&quot;</span>+ i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure>

<h2 id="18-4线程安全"><a href="#18-4线程安全" class="headerlink" title="18.4线程安全"></a>18.4线程安全</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">多线程访问了共享的数据，就会产生线程安全问题</span><br><span class="line">		runableomp1 run = <span class="keyword">new</span> runableomp1();</span><br><span class="line">        Thread to = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(run);</span><br><span class="line">        to.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span></span><br><span class="line">                        + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	如何解决</span><br><span class="line">    		<span class="number">1.</span>同步代码块</span><br><span class="line">    			通过同步代码块中的锁对象，可以使用任意对象</span><br><span class="line">    			但是必须保证多个线程使用的锁对象是同一个</span><br><span class="line">    			吧同步代码块锁住，只让一个线程执行</span><br><span class="line">    			</span><br><span class="line">    				  <span class="comment">/*创建一个锁对象*/</span></span><br><span class="line">    					Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    					<span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                            共享的资源</span><br><span class="line">    					&#125;</span><br><span class="line"></span><br><span class="line">    		<span class="number">2.</span>同步方法</span><br><span class="line">    			把共享数据的方法抽取出来，方法一个方法中，加一个修饰符 <span class="keyword">synchronized</span></span><br><span class="line">    			    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">tic</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        放入里面，然后调用</span><br><span class="line">    			    &#125;</span><br><span class="line">    			    </span><br><span class="line">    			  只让一个线程执行，</span><br><span class="line">    			  锁对象是<span class="keyword">this</span></span><br><span class="line">    			  静态方法也可以保证安全</span><br><span class="line">    			  锁对象不是<span class="keyword">this</span></span><br><span class="line">    		<span class="number">3.</span>锁机制</span><br><span class="line">    			lock，比以上两种方法的操作更加广泛</span><br><span class="line">    			lock()</span><br><span class="line">    			unlock()</span><br><span class="line">    			<span class="number">1.</span>在成员位置创建一个reentranlock对象</span><br><span class="line">    			<span class="number">2.</span>在可能出现问题的前面 加一个 lock()</span><br><span class="line">    			<span class="number">3.</span>在可能出现问题的后面 加一个 unlock()</span><br></pre></td></tr></table></figure>

<h2 id="18-5线程状态"><a href="#18-5线程状态" class="headerlink" title="18.5线程状态"></a>18.5线程状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">阻塞状态	具有执行资格，等待cpu空闲执行,没有争取到锁对象</span><br><span class="line">休眠状态	放弃执行资格，cpu空闲也不执行，计时等待状态 sleep()</span><br><span class="line">			<span class="number">1.</span>sleep()  进入计时等待</span><br><span class="line">			<span class="number">2.</span>wait() 如果wait没有在毫秒结束，那么就会自动醒来状态</span><br><span class="line">无限等待状态  wait() 等待  notify()唤醒</span><br><span class="line">			保证等待和唤醒只有一个可以执行，需要只用同步技术</span><br><span class="line">			顾客 <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                obj.wait()</span><br><span class="line">			&#125;</span><br><span class="line">			老板 <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                obj.notify()</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			唤醒方法</span><br><span class="line">				<span class="number">1.</span>notify</span><br><span class="line">				<span class="number">2.</span>notifyALL  唤醒所有等待线程</span><br><span class="line">死亡状态</span><br><span class="line">新建状态</span><br><span class="line">运行状态</span><br><span class="line">		可以相互转化</span><br></pre></td></tr></table></figure>

<h2 id="18-6线程通信状态"><a href="#18-6线程通信状态" class="headerlink" title="18.6线程通信状态"></a>18.6线程通信状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多个线程之间进行协调通信，共同操作同一个数据</span><br><span class="line">		wait</span><br><span class="line">		notify</span><br><span class="line">		</span><br><span class="line">		锁对象调用的时候，唤醒和等待必须是同一个锁对象</span><br></pre></td></tr></table></figure>

<h2 id="18-7线程池"><a href="#18-7线程池" class="headerlink" title="18.7线程池"></a>18.7线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">我们使用线程的时候是创建一个线程，这样就有了一个问题</span><br><span class="line">	如果并发的数量很多，这样频繁的创建就会大大降低系统的效率，因为创建销毁需要时间</span><br><span class="line">	有了线程池</span><br><span class="line">	</span><br><span class="line">	线程池，容器 集合 Arraylist Hashset LinkedLish  hashmap</span><br><span class="line">	</span><br><span class="line">	list.remove()  返回的是被移除的线程，</span><br><span class="line">	list.add()   添加使用完毕的线程</span><br><span class="line">	</span><br><span class="line">	jdk1<span class="number">.5</span>之后</span><br><span class="line">	内置了线程池，我们可以直接使用</span><br><span class="line">		java.util.concurrent.executors  线程池的工厂类，可以用来创建线程池</span><br><span class="line">			这是一个静态方法</span><br><span class="line">			参数   nthreads  线程的数量</span><br><span class="line">			返回值  executorService接口</span><br><span class="line">				submit() 提交</span><br><span class="line">				shutdown()  销毁</span><br><span class="line">				</span><br><span class="line">		使用步骤</span><br><span class="line">			<span class="number">1.</span>使用线程池的工厂类创建一个指定数量的线程池</span><br><span class="line">			<span class="number">2.</span>创建一个类 ，实现runable接口，重写run方法，设置线程任务</span><br><span class="line">			<span class="number">3.</span>调用executorService中的方法 submit() 传递线程任务，开启线程，执行run方法</span><br><span class="line">			<span class="number">4.</span>销毁线程池（一般不会销毁）</span><br><span class="line">			</span><br><span class="line">			  ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">                es.submit(<span class="keyword">new</span> impl4());</span><br><span class="line">                es.submit(<span class="keyword">new</span> impl4());</span><br><span class="line">                es.submit(<span class="keyword">new</span> impl4());</span><br><span class="line">                </span><br><span class="line">                线程池使用完了，会自动归还给线程池，</span><br><span class="line">			</span><br></pre></td></tr></table></figure>

<h2 id="18-8-lambda表达式"><a href="#18-8-lambda表达式" class="headerlink" title="18.8 lambda表达式"></a>18.8 lambda表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">函数编程式思想</span><br><span class="line">	强调做什么，而不是以什么形式去做</span><br><span class="line">	（）-&gt;&#123;</span><br><span class="line">        业务逻辑</span><br><span class="line">	&#125;</span><br><span class="line">	无参无返回</span><br><span class="line">	cookie(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;吃饭了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">     有参有返回</span><br><span class="line">      Arrays.sort(pe,(Person o1, Person o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">       lambda表达式是可推导可以省略的</span><br><span class="line">       	 凡是上下文推导的内容，都可以省略</span><br><span class="line">       	 <span class="number">1.</span>(参数列表): 括号中的参数列表数据类型可以不写</span><br><span class="line">       	 <span class="number">2.</span>参数列表括号中的参数如果只有一个，那么类型和（）都可以省略</span><br><span class="line">       	 <span class="number">3.</span>如果大括号中，只有一行，无论是否有返回值，都可以省略&#123;&#125;，<span class="keyword">return</span>。分号</span><br><span class="line">       	 </span><br><span class="line">       	 Arrays.sort(pe,(o1,o2)-&gt;o1.getAge()-o2.getAge());</span><br></pre></td></tr></table></figure>

<h1 id="十九-File-类"><a href="#十九-File-类" class="headerlink" title="十九.File 类"></a>十九.File 类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">windows   <span class="comment">//////    有区别</span></span><br><span class="line">linux			\\\\\\</span><br><span class="line"></span><br><span class="line">pathseparator</span><br><span class="line"></span><br><span class="line">			<span class="number">1.</span>注意路径是不区分大小写的</span><br><span class="line">			<span class="number">2.</span>路径中的文件名称分隔符windows使用反斜杠，两个反斜杠是一个普通的反斜杠，因为转义字符</span><br></pre></td></tr></table></figure>

<h2 id="19-1构造方法"><a href="#19-1构造方法" class="headerlink" title="19.1构造方法"></a>19.1构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;pathname&quot;</span>)</span><br><span class="line">		一个参数 选择路径</span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;父&quot;</span>，“子”)  参数都是 String</span><br><span class="line">		父路径和子路径可以单独书写</span><br><span class="line">File f1 = <span class="keyword">new</span> File(<span class="string">&quot;父&quot;</span>，“子”)  参数<span class="number">1</span>是 File类，参数<span class="number">2</span>是 String</span><br><span class="line">	父类可以调用File的方法</span><br><span class="line">	</span><br><span class="line">常用方法</span><br><span class="line">    file.getAbsolutepath  获取绝对路径</span><br><span class="line">    file.getepath  获取路径，传入构造方法的就是什么</span><br><span class="line">    file.getname()    返回文件夹名称或者是文件名称</span><br><span class="line">    file.length()  返回的是文件的大小，返回的是字节</span><br><span class="line"></span><br><span class="line">判断</span><br><span class="line">	exists()  判断构造方法的路径是否存在</span><br><span class="line">	isDirectory()  判断是否为目录</span><br><span class="line">	isFile()  判断是否为文件</span><br></pre></td></tr></table></figure>

<h2 id="19-2创建删除遍历"><a href="#19-2创建删除遍历" class="headerlink" title="19.2创建删除遍历"></a>19.2创建删除遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">file.createNewFile()  当且仅当该名称的文件不存在的时候，创建一个新的空文件</span><br><span class="line">file.delete()   删除由文件或者目录</span><br><span class="line">file.mkdir()  创建File表示的目录</span><br><span class="line">file.mkdirs()   创建file表示的目录，包括不存在的父目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">遍历文件夹</span><br><span class="line">	file.list()		返回一个String数组，表示目录中所有的子文件或者目录</span><br><span class="line">	file.listFiles()  返回一个File数组，表示目录中所有的子文件或者目录</span><br><span class="line">	注意</span><br><span class="line">		<span class="number">1.</span>只能遍历文件夹</span><br><span class="line">		<span class="number">2.</span>路径必须存在</span><br><span class="line">		<span class="number">3.</span>可以遍历到隐藏文件夹</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	过滤器</span><br><span class="line">		第一种</span><br><span class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">filter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    	匿名内部类写法</span><br><span class="line">    		 File[] files = fi.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        lambda优化</span><br><span class="line">        File[] files = fi.listFiles(pathname-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (pathname.isDirectory())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.php&quot;</span>);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="19-3-IO流"><a href="#19-3-IO流" class="headerlink" title="19.3 IO流"></a>19.3 IO流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分为  		输入     输出</span><br><span class="line">	字符流	INputsteam	OUtputstream</span><br><span class="line">	字节流		 Render  Outrender</span><br></pre></td></tr></table></figure>

<h3 id="19-3-1字节输出流"><a href="#19-3-1字节输出流" class="headerlink" title="19.3.1字节输出流"></a>19.3.1字节输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">OUtputstream 抽象类 </span><br><span class="line">	用子类继承  FileOutputStream;把内存中的数据写入硬盘的文件中</span><br><span class="line">	 </span><br><span class="line">	 构造函数</span><br><span class="line">	 		FileOutputStream(String name)</span><br><span class="line">	 		FileOutputStream(File file)</span><br><span class="line">            作用:</span><br><span class="line">            	<span class="number">1.</span>创建一个FileOutputStream对象</span><br><span class="line">            	<span class="number">2.</span>根据构造方法中的文件路径，创建一个空文件</span><br><span class="line">            	<span class="number">3.</span>会把FileOutputStream对象指向创建好的文件</span><br><span class="line">            	</span><br><span class="line">            使用步骤</span><br><span class="line">            	<span class="number">1.</span>创建一个FileOutputStream对象，传递写入的目的地</span><br><span class="line">            	<span class="number">2.</span>调用FileOutputStream对象中的方法write，把数据写入文件</span><br><span class="line">            	<span class="number">3.</span>释放资源</span><br><span class="line">       写入数据	</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">            fos.write(<span class="number">97</span>);<span class="comment">//写入一个字符</span></span><br><span class="line">            fos.close();</span><br><span class="line">        		&#125;</span><br><span class="line">        	写很多</span><br><span class="line">        	<span class="keyword">byte</span>[] by = &#123;<span class="number">65</span>,<span class="number">66</span>,<span class="number">67</span>,<span class="number">68</span>,<span class="number">69</span>&#125;;</span><br><span class="line">        		fos.write(by);</span><br><span class="line">        </span><br><span class="line">        数据的追加写入</span><br><span class="line">        	  FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(</span><br><span class="line">        	  <span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        	换行</span><br><span class="line">        	windows  \r \n</span><br><span class="line">        	linux /n</span><br><span class="line">        	mac /r</span><br><span class="line">        </span><br><span class="line">       任意的文本编辑器</span><br><span class="line">       	打开会查询编码表</span><br><span class="line">       		<span class="number">0</span>-<span class="number">127</span> 查询ascll表</span><br><span class="line">       		其他  查询系统默认编码表</span><br><span class="line">       		gbk编码表</span><br></pre></td></tr></table></figure>

<h3 id="19-3-2-字节输入流"><a href="#19-3-2-字节输入流" class="headerlink" title="19.3.2 字节输入流"></a>19.3.2 字节输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INputsteam</span><br><span class="line">	继承  FileInputStream</span><br><span class="line">	</span><br><span class="line">		读取</span><br><span class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = fis.read();</span><br><span class="line">                System.out.println(len);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">         读取所有</span><br><span class="line">         	 FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> ((len = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">          <span class="comment">/*一次读取多个字节*/</span></span><br><span class="line">                <span class="keyword">byte</span>[] bts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">                <span class="keyword">int</span> len = fis.read(bts);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bts));</span><br></pre></td></tr></table></figure>

<h3 id="19-3-3-字符输入流"><a href="#19-3-3-字符输入流" class="headerlink" title="19.3.3 字符输入流"></a>19.3.3 字符输入流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个中文</span><br><span class="line">	gbk 中文占两个字节</span><br><span class="line">	utf8 中文占<span class="number">3</span>个字节</span><br><span class="line">	Render   FileRender</span><br></pre></td></tr></table></figure>

<h3 id="19-3-4字符输出流"><a href="#19-3-4字符输出流" class="headerlink" title="19.3.4字符输出流"></a>19.3.4字符输出流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Outrender</span><br><span class="line"></span><br><span class="line">	写入字符需要调用  flush()方法  刷新</span><br><span class="line">			close()   关闭也可以写入‘</span><br><span class="line">	区别是   close()关闭流  flush()没有关闭</span><br></pre></td></tr></table></figure>

<h3 id="19-3-5-处理IO流中的异常"><a href="#19-3-5-处理IO流中的异常" class="headerlink" title="19.3.5 处理IO流中的异常"></a>19.3.5 处理IO流中的异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] bts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> len = fis.read(bts);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   fis.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="keyword">new</span> String(bts));</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">      jdk7新特性</span><br><span class="line">      		<span class="keyword">try</span>后面加一个(),在括号中定义流对象，执行完毕自动释放，不需要<span class="keyword">finally</span></span><br><span class="line">      		</span><br><span class="line">      		<span class="keyword">try</span>(流对象定义)&#123;</span><br><span class="line">               </span><br><span class="line">      		&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">               </span><br><span class="line">      		&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-6-properties集合"><a href="#19-3-6-properties集合" class="headerlink" title="19.3.6 properties集合"></a>19.3.6 properties集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">继承  Hashtab集合，有key value  双链集合</span><br><span class="line">是唯一一个和  IO流 相关的方法</span><br><span class="line">		可以使用properties集合中的方法Store，把集合中的临时数据，持久化写入硬盘中</span><br><span class="line">		可以使用properties集合中的方法load，把硬盘中保存的键值对，读取到集合中使用</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		setproperties()</span><br><span class="line">		getproperties()</span><br><span class="line">		</span><br><span class="line">	操作方法集合的使用</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;赵丽颖&quot;</span>,<span class="string">&quot;168&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;高圆圆&quot;</span>,<span class="string">&quot;175&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;刘诗诗&quot;</span>,<span class="string">&quot;172&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key: set)&#123;</span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.print(key + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	写入</span><br><span class="line">    		Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;赵丽颖&quot;</span>,<span class="string">&quot;168&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;高圆圆&quot;</span>,<span class="string">&quot;175&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;刘诗诗&quot;</span>,<span class="string">&quot;172&quot;</span>);</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">        prop.store(fw,<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">        fw.close();</span><br><span class="line">        </span><br><span class="line">        读取</span><br><span class="line">        	 Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">        prop.load(fr);</span><br><span class="line">        Set&lt;String&gt; set = prop.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key: set)&#123;</span><br><span class="line">            String value = prop.getProperty(key);</span><br><span class="line">            System.out.print(key + value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-4-缓冲流"><a href="#19-4-缓冲流" class="headerlink" title="19.4 缓冲流"></a>19.4 缓冲流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给基本的字节输入流增加一个缓冲区，提高基本的字符输入输出流的读取效率</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			 FileReader fis = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\java\\学习\\a.txt&quot;</span>);</span><br><span class="line">        BufferedReader bis = <span class="keyword">new</span> BufferedReader(fis);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        bis.close();</span><br></pre></td></tr></table></figure>

<h2 id="19-5-转化流"><a href="#19-5-转化流" class="headerlink" title="19.5 转化流"></a>19.5 转化流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符编码</span><br><span class="line">字符集</span><br><span class="line">		对应</span><br><span class="line">		</span><br><span class="line">		unicode  万国码</span><br><span class="line">		</span><br><span class="line">		OUtputStreamWrite转码</span><br><span class="line">		和缓冲流一个原理，参数可以传 编码表</span><br></pre></td></tr></table></figure>

<h2 id="19-6序列化和反序列化"><a href="#19-6序列化和反序列化" class="headerlink" title="19.6序列化和反序列化"></a>19.6序列化和反序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">将对象写入文件或者读取对象，使用它</span><br><span class="line">	什么是Serializable接口</span><br><span class="line">		一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化</span><br><span class="line">	什么是序列化？</span><br><span class="line">		序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</span><br><span class="line">	具体概念</span><br><span class="line">		把对象转换为字节序列的过程称为对象的序列化</span><br><span class="line">		把字节序列恢复为对象的过程称为对象的反序列化</span><br><span class="line">	什么情况下需要序列化</span><br><span class="line">		当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化</span><br><span class="line"></span><br><span class="line">	ObjectInputStream</span><br><span class="line">	ObjectOutputStream</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">transient</span>  瞬态关键字  被修饰的关键字不能被序列化</span><br><span class="line">	<span class="keyword">static</span>  不能序列化</span><br><span class="line">	</span><br><span class="line">	异常解决INvalidClassException异常  p402</span><br></pre></td></tr></table></figure>

<h1 id="二十-网络编程"><a href="#二十-网络编程" class="headerlink" title="二十.网络编程"></a>二十.网络编程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Tcp/Ip 协议</span><br><span class="line">	分为四层</span><br><span class="line">		应用层			Http/https/dns</span><br><span class="line">		传输层			Tcp/Udp</span><br><span class="line">		网络层			ip</span><br><span class="line">		数据链路层/物理层		计算机底层网络协议</span><br><span class="line">		</span><br><span class="line">	协议分类</span><br><span class="line">		UDp		</span><br><span class="line">			无连接通信，音频，视频，消耗资源小，通信效率高，</span><br><span class="line">			不能保证数据的完整行</span><br><span class="line">			数据被限制 64kb以内</span><br><span class="line">		Tcp</span><br><span class="line">			传输控制协议，面向连接</span><br><span class="line">			三次握手</span><br><span class="line">				<span class="number">1.</span>客户端向服务器发送连接请求，等待服务器确认</span><br><span class="line">				<span class="number">2.</span>服务器端给客户端一个相应，通知客户端收到了连接请求</span><br><span class="line">				<span class="number">3.</span>客户端再次向服务器发送请求，确认连接</span><br><span class="line">				</span><br><span class="line">		三要素</span><br><span class="line">			协议</span><br><span class="line">			ip地址</span><br><span class="line">				ipv4  <span class="number">32</span>位</span><br><span class="line">				ipv6  <span class="number">128</span>位</span><br><span class="line">                    ipconfig</span><br><span class="line">                    ping ip地址</span><br><span class="line">			端口号</span><br></pre></td></tr></table></figure>

<h2 id="20-1-TCP通信"><a href="#20-1-TCP通信" class="headerlink" title="20.1 TCP通信"></a>20.1 TCP通信</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.net.Socket  客户端</span><br><span class="line">java.net.ServerSocket 服务端</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>服务器端先启动</span><br><span class="line">	<span class="number">2.</span>客户端请求服务器端</span><br><span class="line">	<span class="number">3.</span>建立逻辑连接</span><br><span class="line">	<span class="number">4.</span>这个对象就是 IO对象 字节流对象</span><br><span class="line">	</span><br><span class="line">	注意</span><br><span class="line">		<span class="number">1.</span>服务器端有一个方法，叫accept可以获取到请求的对象，</span><br><span class="line">		<span class="number">2.</span>多个客户端同时和服务器进行交互，就需要使用多个IO流对象</span><br></pre></td></tr></table></figure>

<h2 id="20-2客户端实现"><a href="#20-2客户端实现" class="headerlink" title="20.2客户端实现"></a>20.2客户端实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  方法</span><br><span class="line">	getOutputStream()		输出流</span><br><span class="line">    getIutputStream()		输入流</span><br><span class="line">    close()   				关闭流</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket sc = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7888</span>);</span><br><span class="line">        OutputStream ops = sc.getOutputStream();</span><br><span class="line">        ops.write(<span class="string">&quot;你好服务器&quot;</span>.getBytes());</span><br><span class="line">        InputStream is = sc.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-3服务器端代码实现"><a href="#20-3服务器端代码实现" class="headerlink" title="20.3服务器端代码实现"></a>20.3服务器端代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用accept 获取到客户端对象</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">7888</span>);</span><br><span class="line">        Socket socket = ss.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;收到谢谢！&quot;</span>.getBytes());</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    上传文件</span><br></pre></td></tr></table></figure>

<h1 id="二十一-函数式接口"><a href="#二十一-函数式接口" class="headerlink" title="二十一.函数式接口"></a>二十一.函数式接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">只能有一个抽象方法的接口</span><br><span class="line">注解</span><br><span class="line">	<span class="meta">@functioninterce</span>  检测</span><br><span class="line">	</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ad(<span class="keyword">new</span> interimp() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;函数式编程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">(interimp imp)</span> </span>&#123;</span><br><span class="line">        imp.method();</span><br><span class="line">    &#125;</span><br><span class="line">    简化	 ad(()-&gt;System.out.println(<span class="string">&quot;函数式编程&quot;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="二十二-Java-web基础加强"><a href="#二十二-Java-web基础加强" class="headerlink" title="二十二. Java web基础加强"></a>二十二. Java web基础加强</h1><h2 id="1-Junit-单元测试"><a href="#1-Junit-单元测试" class="headerlink" title="1. Junit 单元测试"></a>1. Junit 单元测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">黑盒测试</span><br><span class="line">	输入一个值，看能否达到预期，不关心逻辑内容，不需要写代码</span><br><span class="line">白盒测试</span><br><span class="line">	需要写入代码，关注代码具体的执行流程</span><br><span class="line">	Junit就是白盒测试</span><br><span class="line">	</span><br><span class="line">	步骤</span><br><span class="line">		<span class="number">1.</span>定义一个测试类</span><br><span class="line">		<span class="number">2.</span>定义一个测试方法</span><br><span class="line">				返回值 <span class="keyword">void</span></span><br><span class="line">				参数 空参</span><br><span class="line">				给方法加<span class="meta">@test</span></span><br><span class="line">		<span class="number">3.</span>导入</span><br><span class="line">		<span class="number">4.</span>断言</span><br><span class="line">		</span><br><span class="line">			  <span class="meta">@Test</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">                    <span class="comment">/*断言*/</span></span><br><span class="line">                    Assert.assertEquals(<span class="number">3</span>,a);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">        初始化</span><br><span class="line">        		<span class="meta">@before</span></span><br><span class="line">        		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        			<span class="comment">//资源申请，所有测试方法之前</span></span><br><span class="line">        		&#125;</span><br><span class="line">        		</span><br><span class="line">        		<span class="meta">@after</span></span><br><span class="line">        		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        			<span class="comment">//资源释放，所有测试方法之后</span></span><br><span class="line">        		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2.反射"></a>2.反射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">将类的各个组成部分封装为其他对象，这就是反射机制</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	三个阶段</span><br><span class="line">        <span class="number">1.</span>source源代码阶段</span><br><span class="line">        <span class="number">2.</span>class类对象阶段</span><br><span class="line">        	通过ClassLoader类加载器把 .class字节码文件加载进入内存</span><br><span class="line">			然后加载成 <span class="class"><span class="keyword">class</span>类对象</span></span><br><span class="line"><span class="class">				成员变量封装被<span class="title">fields</span>对象</span></span><br><span class="line"><span class="class">				构造方法封装成<span class="title">construct</span>对象</span></span><br><span class="line"><span class="class">				成员方法封装成<span class="title">methods</span>对象</span></span><br><span class="line"><span class="class">        3.<span class="title">runtime</span>阶段</span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">        好处，</span></span><br><span class="line"><span class="class">        	1.在程序运行过程中，例如代码提示，操作这些对象</span></span><br><span class="line"><span class="class">        	2.解耦，提高程序的可扩展性</span></span><br><span class="line"><span class="class">        	</span></span><br><span class="line"><span class="class">        	</span></span><br><span class="line"><span class="class">        获取<span class="title">class</span>对象的方式</span></span><br><span class="line">        	1.静态方法Class.forName(&quot;全类名“);</span><br><span class="line">        		多用于配置文件</span><br><span class="line">        	<span class="number">2.</span>通过类名的属性<span class="class"><span class="keyword">class</span>来获取，</span></span><br><span class="line"><span class="class">        		多用于参数的传递</span></span><br><span class="line"><span class="class">        	3.对象.<span class="title">getclass</span>()  在<span class="title">Object</span>中 </span></span><br><span class="line"><span class="class">        		多用于对象的获取</span></span><br><span class="line"><span class="class">       		 同一个字节码文件在一次的程序运行过程中只会被加载一次，三个方法获取的方法一样</span></span><br><span class="line"><span class="class">       		 </span></span><br><span class="line"><span class="class">       		 </span></span><br><span class="line"><span class="class">       <span class="title">class</span>对象功能，</span></span><br><span class="line"><span class="class">       	1.获取成员变量</span></span><br><span class="line"><span class="class">       		<span class="title">getFields</span>()   获取所有<span class="title">Public</span>修饰的变量</span></span><br><span class="line"><span class="class">       		<span class="title">getField</span>(<span class="title">String</span> <span class="title">name</span> )</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredFields</span>()	获取所有的成员变量</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredField</span>(<span class="title">String</span> <span class="title">name</span>)</span></span><br><span class="line"><span class="class">       	2.获取构造方法</span></span><br><span class="line"><span class="class">       		<span class="title">getConstructs</span>()</span></span><br><span class="line"><span class="class">       		<span class="title">getConstruct</span>(<span class="title">String</span> <span class="title">name</span> )</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredConstructs</span>()</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredConstruct</span>(<span class="title">String</span> <span class="title">name</span>)</span></span><br><span class="line"><span class="class">       		</span></span><br><span class="line"><span class="class">       		<span class="title">newInstance</span>(<span class="title">p</span>)  构造器创建对象</span></span><br><span class="line"><span class="class">       	3.获取成员方法</span></span><br><span class="line"><span class="class">       		<span class="title">getMethods</span>() 获取所有<span class="title">Public</span>修饰的变量</span></span><br><span class="line"><span class="class">       		<span class="title">getMethod</span>(<span class="title">String</span> <span class="title">name</span> )</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredMethods</span>()  获取所有的成员变量</span></span><br><span class="line"><span class="class">       		<span class="title">getdeclaredMethod</span>(<span class="title">String</span> <span class="title">name</span>)</span></span><br><span class="line"><span class="class">       		</span></span><br><span class="line"><span class="class">       		<span class="title">invoke</span>(<span class="title">p</span>)执行方法</span></span><br><span class="line"><span class="class">       	4.获取类名</span></span><br><span class="line"><span class="class">       		<span class="title">getName</span>()</span></span><br><span class="line"><span class="class">       		</span></span><br><span class="line"><span class="class">       		</span></span><br><span class="line"><span class="class">       		暴力反射</span></span><br><span class="line"><span class="class">       			忽略访问权限修饰符安全检查</span></span><br><span class="line"><span class="class">       			 <span class="title">setAccessible</span>()</span></span><br><span class="line"><span class="class">       	自己写一个框架的步骤</span></span><br><span class="line"><span class="class">       		1.将对象的类名和方法定义在配置文件中</span></span><br><span class="line"><span class="class">       		2.在程序中加载配置文件</span></span><br><span class="line"><span class="class">       		3.使用反射技术加载进入内存</span></span><br><span class="line"><span class="class">       		4.创建对象</span></span><br><span class="line"><span class="class">       		5.执行方法</span></span><br><span class="line"><span class="class">       		</span></span><br><span class="line"><span class="class">       		 <span class="title">Properties</span> <span class="title">pro</span> </span>= <span class="keyword">new</span> Properties();</span><br><span class="line">                ClassLoader classLoader = reflect.class.getClassLoader();</span><br><span class="line">                InputStream io = classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);</span><br><span class="line">                pro.load(io);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*获取数据*/</span></span><br><span class="line">                String cs = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">                String method = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*加载进入内存*/</span></span><br><span class="line">                Class cl = Class.forName(cs);</span><br><span class="line">                Object obj = cl.newInstance();</span><br><span class="line">                Method md = cl.getMethod(method);</span><br><span class="line">                md.invoke(obj);</span><br></pre></td></tr></table></figure>

<h2 id="3-注解"><a href="#3-注解" class="headerlink" title="3.注解"></a>3.注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">用文字来描述程序，说明程序</span><br><span class="line">	<span class="number">1.</span>编写文档</span><br><span class="line">	<span class="number">2.</span>代码分析</span><br><span class="line">	<span class="number">3.</span>编译检查</span><br><span class="line">	</span><br><span class="line">	javadoc 文件名  可以生成文档</span><br><span class="line">	javac 	编译</span><br><span class="line">	javap  反编译</span><br><span class="line">	</span><br><span class="line">	内置注解</span><br><span class="line">		<span class="meta">@override</span>			重写父类的方法</span><br><span class="line">		<span class="meta">@Deprecated</span>			该注解标注的内容已经过时</span><br><span class="line">							两个方法，以前的方法不删除</span><br><span class="line">							该用还是用</span><br><span class="line">		<span class="meta">@suppressWarning(&quot;all&quot;)</span>	压制警告</span><br><span class="line">							不想看到提示</span><br><span class="line">				</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@version</span> 1.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	自定义注解</span><br><span class="line">		</span><br><span class="line">		注解的本质：就是一个接口，该接口默认继承其他接口	</span><br><span class="line">        元注解</span><br><span class="line">        	<span class="meta">@Target</span>  描述注解能够作用的位置</span><br><span class="line">        	<span class="meta">@Rentention</span> 描述注解保留的阶段</span><br><span class="line">            <span class="meta">@Documented</span> 描述注解是否能够被抽取到api文档中</span><br><span class="line">            <span class="meta">@inherited</span> 描述注解是否能被子类继承</span><br><span class="line">		<span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">            </span><br><span class="line">		&#125;</span><br><span class="line">		属性：接口中的抽象方法</span><br></pre></td></tr></table></figure>

<h1 id="二十三-数据库操作"><a href="#二十三-数据库操作" class="headerlink" title="二十三.数据库操作"></a>二十三.数据库操作</h1><h2 id="23-1数据库范式"><a href="#23-1数据库范式" class="headerlink" title="23.1数据库范式"></a>23.1数据库范式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">第一范式	</span><br><span class="line">		每一列都是不可分割的原子数据项</span><br><span class="line">		不是合并的列，一列不能再分成其他列，</span><br><span class="line">			存在非常严重的数据冗余，</span><br><span class="line">			数据添加数据不合法</span><br><span class="line">			数据删除存在问题，会将其他的数据也会删除</span><br><span class="line">第二范式</span><br><span class="line">		在第一范式的基础上，非码属性必须完全依赖于主码</span><br><span class="line">		例如学号和姓名相互依赖</span><br><span class="line">		码 如果在一张表上面，一个属性或者属性组，被其他属性所完全依赖，称为表</span><br><span class="line">		</span><br><span class="line">		例如 分数依赖于课程和学号</span><br><span class="line">			学生表和成绩表必须分开；</span><br><span class="line">第三范式</span><br><span class="line">		在第二范式(2NF)任何非主属性不依赖于其他非主属性</span><br><span class="line">		消除传递依赖</span><br><span class="line">				</span><br><span class="line">		越高的范式数据库冗余越小</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		通俗理解</span><br><span class="line">第一范式就是属性不可分割，每个字段都应该是不可再拆分的。比如一个字段是姓名（NAME），在国内的话通常理解都是姓名是一个不可再拆分的单位，这时候就符合第一范式；但是在国外的话还要分为FIRST NAME和LAST NAME，这时候姓名这个字段就是还可以拆分为更小的单位的字段，就不符合第一范式了。</span><br><span class="line"></span><br><span class="line">第二范式就是要求表中要有主键，表中其他其他字段都依赖于主键，因此第二范式只要记住主键约束就好了。比如说有一个表是学生表，学生表中有一个值唯一的字段学号，那么学生表中的其他所有字段都可以根据这个学号字段去获取，依赖主键的意思也就是相关的意思，因为学号的值是唯一的，因此就不会造成存储的信息对不上的问题，即学生<span class="number">001</span>的姓名不会存到学生<span class="number">002</span>那里去。</span><br><span class="line"></span><br><span class="line">第三范式就是要求表中不能有其他表中存在的、存储相同信息的字段，通常实现是在通过外键去建立关联，因此第三范式只要记住外键约束就好了。比如说有一个表是学生表，学生表中有学号，姓名等字段，那如果要把他的系编号，系主任，系主任也存到这个学生表中，那就会造成数据大量的冗余，一是这些信息在系信息表中已存在，二是系中有<span class="number">1000</span>个学生的话这些信息就要存<span class="number">1000</span>遍。因此第三范式的做法是在学生表中增加一个系编号的字段（外键），与系信息表做关联。</span><br></pre></td></tr></table></figure>

<h2 id="23-2事务"><a href="#23-2事务" class="headerlink" title="23.2事务"></a>23.2事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">如果一个包含多个步骤的业务操作，被事务管理，要么这些都操作成功，要么都操作失败</span><br><span class="line">例如打钱失败，回退款回来</span><br><span class="line">	出现异常，回滚操作，提交事务</span><br><span class="line">	</span><br><span class="line">	开启事务 strat transaction</span><br><span class="line">	回滚	rollback</span><br><span class="line">	提交事务  commit</span><br><span class="line">	</span><br><span class="line">	在 MYSQl中事务默认自动提交，</span><br><span class="line">		自动提交</span><br><span class="line">		手动提交</span><br><span class="line">		</span><br><span class="line">	四大特征</span><br><span class="line">		<span class="number">1.</span>原子性；要么同时成功要么同时失败，不可分割的最小操作单位</span><br><span class="line">		<span class="number">2.</span>持久性 如果事务一旦提交或者回滚，那么数据库表会被持久的更新</span><br><span class="line">		<span class="number">3.</span>隔离性：多个事物之间，相互影响，相互独立</span><br><span class="line">		<span class="number">4.</span>一致性，事务操作前后，数据总量不变  </span><br><span class="line">		</span><br><span class="line">		存在问题：</span><br><span class="line">			脏读：一个事务，读取到另外一个事务中没有提交的事务</span><br><span class="line">			不可重复读(虚读) 在同一个事务中，两次读取到的数据不一样	</span><br><span class="line">			幻读	一个事务操作数据表中的所有记录，另一个事务添加了一条数据，那么第一个事务查询不到数据</span><br><span class="line">		隔离级别</span><br><span class="line">			read uncommited 读未提交，三种问题都会产生</span><br><span class="line">			read commited 读已提交 会产生后面两种问题 oracle</span><br><span class="line">			repeated read 可重复读  会产生 幻读 mysql</span><br><span class="line">			serializable 串行话，可以解决所有问题</span><br><span class="line">			</span><br><span class="line">			注意隔离级别，从小到大，安全性越来越高，但是效率越来越低</span><br><span class="line">			sql可以设置</span><br></pre></td></tr></table></figure>

<h2 id="23-3-JDBC"><a href="#23-3-JDBC" class="headerlink" title="23.3 JDBC"></a>23.3 JDBC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">使用一套代码操作所有的关系数据库，就是JDBC</span><br><span class="line">	定义了操作所有关系型数据库的规则</span><br><span class="line">	定义了一套接口</span><br><span class="line">	不同的厂商实现了不同的实现类，我们把这些实现类叫做数据库驱动</span><br><span class="line">	</span><br><span class="line">	步骤</span><br><span class="line">		<span class="number">1.</span>导入jar包</span><br><span class="line">		<span class="number">2.</span>注册驱动</span><br><span class="line">		<span class="number">3.</span>获取数据库连接对象</span><br><span class="line">		<span class="number">4.</span>定义sql</span><br><span class="line">		<span class="number">5.</span>获取执行sql语句的对象 statement</span><br><span class="line">		<span class="number">6.</span>执行sql返回结果</span><br><span class="line">		<span class="number">7.</span>处理结果</span><br><span class="line">		<span class="number">8.</span>释放资源</span><br><span class="line">		</span><br><span class="line">		详细解释对象</span><br><span class="line">			<span class="number">1.</span>DriverManager : 驱动管理对象</span><br><span class="line">				<span class="number">1.</span>注册驱动</span><br><span class="line">				<span class="number">2.</span>获取数据库连接</span><br><span class="line">			<span class="number">2.</span>Connection ； 数据库连接对象</span><br><span class="line">				<span class="number">1.</span>执行sql的对象</span><br><span class="line">				<span class="number">2.</span>管理事务</span><br><span class="line">			<span class="number">3.</span>Statement 执行sql的对象  静态sql</span><br><span class="line">				<span class="number">1.</span>执行sql</span><br><span class="line">					excute</span><br><span class="line">					excuteupdate</span><br><span class="line">			<span class="number">4.</span>ResultSet 结果集对象</span><br><span class="line">			<span class="number">5.</span>perparedstatement 执行sql对象  预编译 sql</span><br><span class="line">			参数使用占位符替代</span><br><span class="line">			setxxx(参数<span class="number">1</span>，参数<span class="number">2</span>)</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">	简单操作</span><br><span class="line">		  <span class="comment">/*导入驱动jar包*/</span></span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///jdbc?serverTimezone=UTC&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">            String sql = <span class="string">&quot;insert into student values (18,&#x27;赵某&#x27;)&quot;</span>;</span><br><span class="line">            statement = connection.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = statement.executeUpdate(sql);</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">                System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    statement.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(connection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        sql注入</span><br><span class="line">        	在拼接sql时候有些关键字参与拼接，解决安全性问题</span><br><span class="line">        	password = ‘a’ or ‘a’ = ‘a’;</span><br><span class="line">        	</span><br><span class="line">        	</span><br><span class="line">       事务</span><br><span class="line">       		<span class="number">1.</span>开启事务 setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">       		<span class="number">2.</span>回滚	commit();</span><br><span class="line">       		<span class="number">3.</span>提交事务	rollback();</span><br></pre></td></tr></table></figure>

<h2 id="23-4数据库连接池"><a href="#23-4数据库连接池" class="headerlink" title="23.4数据库连接池"></a>23.4数据库连接池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">实现DATASource接口</span><br><span class="line">	<span class="number">1.</span>获取连接	getconnection()</span><br><span class="line">	<span class="number">2.</span>归还连接	close();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>C3P0	数据库连接池</span><br><span class="line"><span class="number">2.</span>DRuid  阿里巴巴连接池</span><br><span class="line">	<span class="number">1.</span>导入jar包</span><br><span class="line">	<span class="number">2.</span>定义配置文件</span><br><span class="line">		<span class="number">1.</span>是 properties形式的</span><br><span class="line">		<span class="number">2.</span>可以叫任意名称</span><br><span class="line">	<span class="number">3.</span>获取数据库连接池对象，：通过工厂来获取，</span><br><span class="line">	<span class="number">4</span>获取连接</span><br><span class="line">	</span><br><span class="line">		 <span class="comment">/*加载配置文件*/</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = 		druid.class.getClassLoader().getResourceAsStream(<span class="string">&quot;druid.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">/*获取连接池对象*/</span></span><br><span class="line">        DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        <span class="comment">/*获取连接*/</span></span><br><span class="line">        Connection connection = ds.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        定义工具类</span><br><span class="line">        	  Connection connection =<span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement preparedStatement = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = jdbvutils.getConnection();</span><br><span class="line">            String sql = <span class="string">&quot;insert into student values(?,?)&quot;</span>;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setString(<span class="number">1</span>,<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">            preparedStatement.setInt(<span class="number">2</span>,<span class="number">15</span>);</span><br><span class="line">            <span class="keyword">int</span> i = preparedStatement.executeUpdate();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            jdbvutils.close(preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Spring template</span><br><span class="line">        	<span class="number">1.</span>导入五个包</span><br><span class="line">        	<span class="number">2.</span>创建jdbctemplate对象，依赖数据源Datesource</span><br><span class="line">        	<span class="number">3.</span>调用jdbctemplate方法来执行</span><br><span class="line">        	</span><br><span class="line">       JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(JdbcUtils.get);</span><br><span class="line">        String sql = <span class="string">&quot;updata ....?&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="二十四-Java-web"><a href="#二十四-Java-web" class="headerlink" title="二十四. Java web"></a>二十四. Java web</h1><h2 id="24-1服务器"><a href="#24-1服务器" class="headerlink" title="24.1服务器"></a>24.1服务器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weblogic  oracle付费版  收费 大型</span><br><span class="line">websphere ibm公司  收费 大型</span><br><span class="line">Jboss  jboss  收费  大型</span><br><span class="line">tomacat apache基金组织，中小型 javaee服务器  开源的</span><br></pre></td></tr></table></figure>

<h2 id="24-1-tomcat"><a href="#24-1-tomcat" class="headerlink" title="24.1 tomcat"></a>24.1 tomcat</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">目录结构 </span><br><span class="line"> 	bin  可执行文件</span><br><span class="line">  conf  配置文件</span><br><span class="line">  lib 依赖的 jar包</span><br><span class="line">  logs 日志文件</span><br><span class="line">  temp 临时文件</span><br><span class="line">  webapps 存放项目的</span><br><span class="line">  work 存放运行时的数据</span><br><span class="line">  </span><br><span class="line">  配置</span><br><span class="line">  	<span class="number">1.</span>直接将项目放到webapps下面</span><br><span class="line">  	<span class="number">2.</span>修改压缩改成war包,然后拖进去</span><br><span class="line">  	<span class="number">3.</span>配置conf/server.xml;</span><br><span class="line">  	</span><br><span class="line">  	静态项目</span><br><span class="line">  	动态项目</span><br><span class="line">  		--webinfo</span><br><span class="line">  			--web.xml</span><br><span class="line">  			--classse目录</span><br><span class="line">  			--lib目录</span><br><span class="line">  			</span><br><span class="line">  			</span><br><span class="line"> 将tomcat继承到IDEA中，</span><br></pre></td></tr></table></figure>

<h2 id="24-2-servlet"><a href="#24-2-servlet" class="headerlink" title="24.2 servlet"></a>24.2 servlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">server applet  运行在服务器端的小程序</span><br><span class="line">就是一个接口，接口定义了java类，被浏览器访问到的规则</span><br><span class="line">	<span class="number">1.</span>创建javaee项目，</span><br><span class="line">	<span class="number">2.</span>定义一个类，实现servlet接口</span><br><span class="line">	<span class="number">3.</span>实现接口的抽象方法</span><br><span class="line">	<span class="number">4.</span>配置</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	web.xml</span><br><span class="line">		   &lt;!--配置servlet--&gt;</span><br><span class="line">                &lt;servlet&gt;</span><br><span class="line">                    &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">                    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">servlet</span>.<span class="title">demo</span>.<span class="title">demo</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;!--映射--&gt;</span></span><br><span class="line"><span class="class">                &lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">                    &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">                    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">demo1</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">                </span></span><br><span class="line"><span class="class">      生命周期</span></span><br><span class="line"><span class="class">      		<span class="title">init</span>()  初始化 方法，在<span class="title">servlet</span>被创建时候执行，只会执行一次</span></span><br><span class="line"><span class="class">      		<span class="title">service</span>()  每次<span class="title">servlet</span>被访问执行</span></span><br><span class="line"><span class="class">      		<span class="title">destory</span>()  销毁方法，<span class="title">servlet</span>被杀死时候执行</span></span><br><span class="line"><span class="class">      		<span class="title">servlet</span>()  用来获取配置对象</span></span><br><span class="line"><span class="class">      		<span class="title">getservletinfo</span>()  获取<span class="title">servlet</span>() 信息</span></span><br><span class="line"><span class="class">      </span></span><br><span class="line"><span class="class">      </span></span><br><span class="line"><span class="class">      <span class="title">servlet3</span>.0注解配置</span></span><br><span class="line"><span class="class">      		好处：支持注解配置，</span></span><br><span class="line"><span class="class">      		在类上面使用 <span class="title">webservlet</span>注解</span></span><br><span class="line"><span class="class">      		</span></span><br><span class="line"><span class="class">      		@<span class="title">webservlet</span>(<span class="title">urlpatterns</span> </span>= <span class="string">&quot;demo&quot;</span>)</span><br><span class="line">      </span><br><span class="line">      servlet 体系结构</span><br><span class="line">      		<span class="number">1.</span>servlet  接口</span><br><span class="line">      		<span class="number">2.</span>genericservlet	抽象类</span><br><span class="line">      			以后写直接结成这个抽象类就可以了</span><br><span class="line">      		<span class="number">3.</span>httpservlet	抽象类</span><br><span class="line">      			用的比较多</span><br><span class="line">      			对http协议的一种粉装，简化操作</span><br><span class="line">      			复写doGet/doPost方法</span><br><span class="line">      	配置</span><br><span class="line">      		<span class="meta">@webservlet(&#123;&quot;demo1&quot;,&quot;demo2&quot;,&quot;demo3&quot;&#125;)</span></span><br><span class="line">      		三种配置</span><br><span class="line">      			<span class="number">1.</span>/xxx</span><br><span class="line">      			<span class="number">2.</span>/xxx/xxx  /user/demo4</span><br><span class="line">      			<span class="number">3.</span>*.<span class="keyword">do</span>  *.dao   任何都可以访问</span><br><span class="line">      		</span><br></pre></td></tr></table></figure>

<h2 id="24-3-request"><a href="#24-3-request" class="headerlink" title="24.3 request"></a>24.3 request</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">request继承体系</span><br><span class="line">	servletrequest  接口</span><br><span class="line">			继承</span><br><span class="line">	httpservletrequest  接口</span><br><span class="line">			实现</span><br><span class="line">	requestfacade</span><br><span class="line"></span><br><span class="line">request获取请求消息数据</span><br><span class="line">	<span class="number">1.</span>获取请求行数据</span><br><span class="line">		获取请求方式  getMethod()</span><br><span class="line">		虚拟目录	getcontextpath()</span><br><span class="line">		servlet路径 getservletpath()</span><br><span class="line">		获取请求参数	getqueryString()</span><br><span class="line">		获取请求<span class="function">url <span class="title">getrequestURI</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		获取客户机ip地址	<span class="title">getremoteaddr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		 <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>				</span>&#123;</span><br><span class="line">        		String s = request.getQueryString();</span><br><span class="line">        		System.out.println(s);</span><br><span class="line">    		&#125;</span><br><span class="line">    <span class="number">2.</span>获取请求头的数据</span><br><span class="line">    	getHeader(name)  获取请求头的值 </span><br><span class="line">    	getHeaderName()	 获取请求头名称</span><br><span class="line">    	</span><br><span class="line">    	防盗链</span><br><span class="line">    	</span><br><span class="line">    	 Enumeration&lt;String&gt; headName = request.getHeaderNames();</span><br><span class="line">         <span class="keyword">while</span>(headName.hasMoreElements())&#123;</span><br><span class="line">                String name = headName.nextElement();</span><br><span class="line">                String value = request.getHeader(name);</span><br><span class="line">             System.out.println(name+<span class="string">&quot;-----&quot;</span>+value);</span><br><span class="line">         &#125;</span><br><span class="line">    	得到</span><br><span class="line">    	host-----localhost:<span class="number">8080</span></span><br><span class="line">connection-----keep-alive</span><br><span class="line">upgrade-insecure-requests-----<span class="number">1</span></span><br><span class="line">user-agent-----Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">79.0</span><span class="number">.3945</span><span class="number">.130</span> Safari/<span class="number">537.36</span></span><br><span class="line">sec-fetch-user-----?<span class="number">1</span></span><br><span class="line">accept-----text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="comment">sec-fetch-site-----none</span></span><br><span class="line"><span class="comment">sec-fetch-mode-----navigate</span></span><br><span class="line"><span class="comment">accept-encoding-----gzip, deflate, br</span></span><br><span class="line"><span class="comment">accept-language-----zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7</span></span><br><span class="line"><span class="comment">cookie-----Webstorm-c7ae48fb=ad1984c8-fa5b-4222-8441-e07386c40845; pgv_pvi=4967734272; JSESSIONID=3D36D24A77F95694E4E8330F59751CF5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	3.获取请求体</span></span><br><span class="line"><span class="comment">		只有POST请求有请求体</span></span><br><span class="line"><span class="comment">			1.获取流对象</span></span><br><span class="line"><span class="comment">			2.再从流中间获取数据</span></span><br><span class="line"><span class="comment">	4.获取请求参数</span></span><br><span class="line"><span class="comment">		getparameter()  根据参数名称获取参数值</span></span><br><span class="line"><span class="comment">		getparametervalues() 更具参数名称获取参数的数组</span></span><br><span class="line"><span class="comment">		getparameterName()  获取u所有请求的参数</span></span><br><span class="line"><span class="comment">		getparametermap()  获取所有键值对</span></span><br><span class="line"><span class="comment">			 1.String username = request.getParameter(&quot;username&quot;);</span></span><br><span class="line"><span class="comment">			 2.Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span></span><br><span class="line"><span class="comment">                    Set&lt;String&gt; strings = parameterMap.keySet();</span></span><br><span class="line"><span class="comment">                    for (String i:strings)&#123;</span></span><br><span class="line"><span class="comment">                        System.out.print(i);</span></span><br><span class="line"><span class="comment">                        String[] strings1 = parameterMap.get(i);</span></span><br><span class="line"><span class="comment">                        for (String g:strings1)&#123;</span></span><br><span class="line"><span class="comment">                            System.out.println(g);</span></span><br><span class="line"><span class="comment">                        &#125;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">              中文方式乱码</span></span><br><span class="line"><span class="comment">              request.setCharacterEncoding(&quot;utf-8&quot;);</span></span><br><span class="line"><span class="comment">	5.请求转发</span></span><br><span class="line"><span class="comment">		一种在服务器内部的资源跳转方式</span></span><br><span class="line"><span class="comment">		A-B  转发</span></span><br><span class="line"><span class="comment">			第一种</span></span><br><span class="line"><span class="comment">				RequestDispatcher requestDispatcher = 		request  .getRequestDispatcher(&quot;/demo2&quot;);</span></span><br><span class="line"><span class="comment">       	 requestDispatcher.forward(request,response);</span></span><br><span class="line"><span class="comment">        	第二种</span></span><br><span class="line"><span class="comment">		1.浏览器地址栏路径没有发生变化</span></span><br><span class="line"><span class="comment">		2.服务器内部资源访问</span></span><br><span class="line"><span class="comment">		3.转发是一次请求，多个资源使用同一个请求</span></span><br><span class="line"><span class="comment">    6.共享数据</span></span><br><span class="line"><span class="comment">    	服务器内部共享数据</span></span><br><span class="line"><span class="comment">    		域对象：一个有作用范围的对象，可以在范围内共享数据</span></span><br><span class="line"><span class="comment">    		request域:代表一次请求的范围</span></span><br><span class="line"><span class="comment">    				1.setattribute(name,obj); 发送数据</span></span><br><span class="line"><span class="comment">    				2.getattribute(name) 获取数据</span></span><br><span class="line"><span class="comment">    				3.removerattribute(name) 移除</span></span><br><span class="line"><span class="comment">    	request.setAttribute(&quot;msg&quot;,&quot;hello!!!&quot;);</span></span><br><span class="line"><span class="comment">    	 Object ms = request.getAttribute(&quot;msg&quot;);</span></span><br><span class="line"><span class="comment">    7.获取servletcontext</span></span><br><span class="line"><span class="comment">    	getservletcontext();获取对象成功</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    8.Beanutils 工具类</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    	简化数据封装</span></span><br><span class="line"><span class="comment">    	 //获取请求参数</span></span><br><span class="line"><span class="comment">        Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span></span><br><span class="line"><span class="comment">        //创建user对象</span></span><br><span class="line"><span class="comment">        User loginUser = new User();</span></span><br><span class="line"><span class="comment">         //使用beanutils</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            BeanUtils.populate(loginUser,parameterMap);</span></span><br><span class="line"><span class="comment">        &#125; catch (IllegalAccessException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125; catch (InvocationTargetException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">       细节</span></span><br><span class="line"><span class="comment">                1.用于封装 javabean 标准的java类</span></span><br><span class="line"><span class="comment">                2.必须提供空参的构造器</span></span><br><span class="line"><span class="comment">                3。成员变量必须用private修饰</span></span><br><span class="line"><span class="comment">                4.提供getter setter类</span></span><br><span class="line"><span class="comment">                </span></span><br><span class="line"><span class="comment">         功能	</span></span><br><span class="line"><span class="comment">         		封装数据的，成员变量</span></span><br></pre></td></tr></table></figure>

<h2 id="24-4-response"><a href="#24-4-response" class="headerlink" title="24.4 response"></a>24.4 response</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">响应头</span><br><span class="line">		Content-Type:服务器告诉客户端本次相应体数据格式和编码格式</span><br><span class="line">		CONtent-disposition 服务器告诉客户端以什么样的格式打开响应体数据</span><br><span class="line">				in-line 默认值</span><br><span class="line">				attachment;filename=xxx 以附件形式打开响应体，文件下载</span><br><span class="line">				</span><br><span class="line">		状态码 1xx;服务器端开始接受客户端信息，但是没有接受完成，</span><br><span class="line">		  2xx: 成功</span><br><span class="line">		  3xx 重定向 <span class="number">302</span>重定向 <span class="number">304</span>访问缓存</span><br><span class="line">		  4xx 客户端错误	<span class="number">404</span>路径错误 <span class="number">405</span>请求方式没有对应的方法</span><br><span class="line">		  5xx 服务器端错误	<span class="number">500</span>服务器内部出现异常，</span><br><span class="line">相应行</span><br><span class="line">	</span><br><span class="line">响应体</span><br><span class="line">	就是传输的数据</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	设置头</span><br><span class="line">		setheader()</span><br><span class="line">	设置响应体</span><br><span class="line">		获取输出流</span><br><span class="line">		使用输入流，将数据输出到浏览器</span><br><span class="line">		字符字节输出流	getwriter()</span><br><span class="line">					getoutputwriter()</span><br><span class="line">					</span><br><span class="line">					</span><br><span class="line">	重定向步骤</span><br><span class="line">			<span class="number">1.</span>设置状态码</span><br><span class="line">			<span class="number">2.</span>设置响应头</span><br><span class="line">			  response.setStatus(<span class="number">302</span>);</span><br><span class="line">       		 response.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;/demo2&quot;</span>);</span><br><span class="line">       		 </span><br><span class="line">       		 优化</span><br><span class="line">       		 	response.sendRedirect(<span class="string">&quot;/demo2&quot;</span>)</span><br><span class="line">       		 	</span><br><span class="line">       		 	特点</span><br><span class="line">       		 		<span class="number">1.</span>转发地址栏路径不变，只能访问当前服务器下的资源，是一次请求</span><br><span class="line">       		 		<span class="number">2.</span>重定向的地址栏发生变化，重定向可以访问其他服务器的资源，重定向是两次请求</span><br><span class="line">       		 		</span><br><span class="line">       输出数据</span><br><span class="line">       	<span class="number">1.</span>获取字符输出流</span><br><span class="line">       	<span class="number">2.</span>输出数据</span><br><span class="line">       		response.setHeader(<span class="string">&quot;content-type&quot;</span>,<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">       			 PrintWriter writer = response.getWriter();</span><br><span class="line">        		<span class="comment">//设置字符集就可以</span></span><br><span class="line">       			 writer.write(<span class="string">&quot;&lt;h1&gt;你好你好hello!!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">       			 </span><br><span class="line">       			 </span><br><span class="line">       			 输出字节流数据 hello.getbytes()</span><br><span class="line">       			 </span><br><span class="line">       	验证码</span><br><span class="line">       	</span><br><span class="line">       	ServletContent  代表整个web应用</span><br><span class="line">       		<span class="number">1.</span>获取mime类型，</span><br><span class="line">       			在互联网通信的过程中的文件类型一种标准，</span><br><span class="line">       				格式 大类型/小类型    text/html  image/jpeg</span><br><span class="line">       				 ServletContext servletContext = request.getServletContext();</span><br><span class="line">                    <span class="comment">//定义一个文件类型</span></span><br><span class="line">                    String filename = <span class="string">&quot;a.jpg&quot;</span>;</span><br><span class="line">                    String mimeType = servletContext.getMimeType(filename);</span><br><span class="line">       		<span class="number">2.</span>域对象，共享数据</span><br><span class="line">       			set/get/remove attribute</span><br><span class="line">       			范围最大，所有用户的数据</span><br><span class="line">       		<span class="number">3.</span>获取文件服务器的真实路径</span><br><span class="line">       			getrealpath(<span class="string">&quot;/b.txt&quot;</span>)</span><br><span class="line">       		</span><br><span class="line">       		</span><br><span class="line">       		处理中文文件的下载展示</span><br><span class="line">       			使用浏览器编码类</span><br><span class="line">       		</span><br></pre></td></tr></table></figure>

<h2 id="24-5-cookie"><a href="#24-5-cookie" class="headerlink" title="24.5 cookie"></a>24.5 cookie</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一次会话中，共享数据，一次会话有多次请求</span><br><span class="line">	<span class="number">1.</span>可以发送多个cookie，默认情况下浏览器关闭cookie消失</span><br><span class="line">		可以持久化保存  setmaxage();</span><br><span class="line">	<span class="number">2.</span>cookie能不能存中文，cookie的范围有多大 tomcat8以后</span><br><span class="line">		不同服务器之间的cookie共享问题，一级域名相同即可</span><br></pre></td></tr></table></figure>

<h2 id="24-6-JSP入门"><a href="#24-6-JSP入门" class="headerlink" title="24.6 JSP入门"></a>24.6 JSP入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java server page;</span><br><span class="line">	既可以指定html标签，也可以定义java代码</span><br><span class="line">	</span><br><span class="line">	原理		本质上也是一个 servlet</span><br><span class="line">		<span class="number">1.</span>服务器解析请求消息，找到jsp页面，</span><br><span class="line">		<span class="number">2.</span>如果找到了，会将jsp转化为 .java文件</span><br><span class="line">		<span class="number">3.</span>会编译java文件 生成<span class="class"><span class="keyword">class</span>文件</span></span><br><span class="line"><span class="class">		4.由字节码文件提供访问</span></span><br><span class="line"><span class="class">		</span></span><br><span class="line"><span class="class">	脚本</span></span><br><span class="line"><span class="class">		<span class="title">jsp</span>声明<span class="title">java</span>代码的方式，</span></span><br><span class="line"><span class="class">		1.&lt;%</span></span><br><span class="line"><span class="class">			<span class="title">java</span>代码 </span></span><br><span class="line"><span class="class">			不在里面，就会编程字符串</span></span><br><span class="line"><span class="class">			%&gt;  </span></span><br><span class="line"><span class="class">				定义在<span class="title">service</span>方法中，可以定义变量</span></span><br><span class="line"><span class="class">		2.&lt;%!  代码 %&gt; 定义成员变量，成员方法 在 <span class="title">java</span>类的成员位置</span></span><br><span class="line"><span class="class">		3.&lt;%</span>=  代码 %&gt; 会输出到页面上，意思就是输出语句</span><br><span class="line">		</span><br><span class="line">	jsp内置对象</span><br><span class="line">		在jsp中，不需要获取和创建对象，直接可以使用的对象</span><br><span class="line">		jsp一共有<span class="number">9</span>个内置对象</span><br><span class="line">		<span class="number">1.</span>request</span><br><span class="line">		<span class="number">2.</span>response</span><br><span class="line">		<span class="number">3.</span>out 将数据输出到页面上</span><br></pre></td></tr></table></figure>

<h2 id="24-7-session"><a href="#24-7-session" class="headerlink" title="24.7 session"></a>24.7 session</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">服务器端会话技术，将数据保存在服务器端的对象中</span><br><span class="line">	<span class="number">1.</span>获取 httpsession对象</span><br><span class="line">		requsest.getsession();</span><br><span class="line">	<span class="number">2.</span>使用httpsession对象</span><br><span class="line">		set/get/<span class="function">remove <span class="title">attribute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">	服务器如何确保再一次会话范围内，多次获取的session是同一个</span></span><br><span class="line"><span class="function">		session id 用来实现</span></span><br><span class="line"><span class="function">		</span></span><br><span class="line"><span class="function">		细节</span></span><br><span class="line"><span class="function">			1.客户端关闭后，再打开 两次sessionid 不一样，希望一样加一个cookie；键位sessionid，设置最大存活时间</span></span><br><span class="line"><span class="function">			2.通过session的钝化，活化可以保存session，为同一个</span></span><br><span class="line"><span class="function">			3.session默认失效时为 30分钟</span></span><br><span class="line"><span class="function">			4.可以存储任意大小的</span></span><br><span class="line"><span class="function">			</span></span><br><span class="line"><span class="function">		和cookie的区别</span></span><br><span class="line"><span class="function">			1.session没有大小限制</span></span><br><span class="line"><span class="function">			2.session在服务器端，cookie存储在客户端</span></span><br><span class="line"><span class="function">			3.session相对于安全一些</span></span><br></pre></td></tr></table></figure>

<h2 id="24-8-JSP深入"><a href="#24-8-JSP深入" class="headerlink" title="24.8 JSP深入"></a>24.8 JSP深入</h2><h3 id="24-8-1指令"><a href="#24-8-1指令" class="headerlink" title="24.8.1指令"></a>24.8.1指令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">作用</span><br><span class="line">	配置jsp页面，导入资源文件</span><br><span class="line">	格式</span><br><span class="line">		&lt;%@ 指令名称 属性值 = <span class="number">1</span> 属性值 = <span class="number">2</span> %&gt;</span><br><span class="line">		分类</span><br><span class="line">			page  配置jsp页面的</span><br><span class="line">					设置响应体的的mime类型以及字符集</span><br><span class="line">					设置jsp页面的编码</span><br><span class="line">					导入java包</span><br><span class="line">					errorpage 发生异常会自动跳转到指定页面</span><br><span class="line">					iserrorpage 可以使用内置对象exception</span><br><span class="line">			include 页面的包含导入页面的资源文件</span><br><span class="line">					包含其他页面 分成几部分jsp互相包含</span><br><span class="line">			tahlib	导入资源的</span><br><span class="line">					导入便签库  jstl例如</span><br><span class="line">					</span><br><span class="line">		注释</span><br><span class="line">			jsp  &lt;%--  --%&gt;</span><br><span class="line">			</span><br><span class="line">		内置对象</span><br><span class="line">			<span class="number">1.</span>pagecontext  当前页面共享数据 ，获取其他<span class="number">8</span>个内置对象  </span><br><span class="line">域对象前面四个<span class="number">2.</span>request	   一次请求访问多个资源</span><br><span class="line">			<span class="number">3.</span>session		一次会话多个请求间</span><br><span class="line">			<span class="number">4.</span>application	多个用户间共享数据 唯一</span><br><span class="line">			<span class="number">5.</span>response		响应对象</span><br><span class="line">			<span class="number">6.</span>page			当前页面的对象</span><br><span class="line">			<span class="number">7.</span>out			输出对象，输出到页面上</span><br><span class="line">			<span class="number">8.</span>config		servlet的配置对象</span><br><span class="line">			<span class="number">9.</span>exception		异常对象</span><br></pre></td></tr></table></figure>

<h3 id="24-8-2-MVC"><a href="#24-8-2-MVC" class="headerlink" title="24.8.2 MVC"></a>24.8.2 MVC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M 模型   业务逻辑操作，查询数据库 					java对象</span><br><span class="line">V 视图	调用模型，将视图展示，获取客户端的输入			servlet</span><br><span class="line">C 控制器	视图展示								jsp</span><br><span class="line"></span><br><span class="line">优点  </span><br><span class="line">	耦合度降低，方便维护 ，分工协作</span><br><span class="line">	重用性高</span><br></pre></td></tr></table></figure>

<h3 id="24-8-3-El表达式"><a href="#24-8-3-El表达式" class="headerlink" title="24.8.3 El表达式"></a>24.8.3 El表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">expression language  </span><br><span class="line">	<span class="number">1.</span>替换简化java代码的书写</span><br><span class="line">	也可以忽略  page里面设置 isELignore = <span class="keyword">true</span></span><br><span class="line">	语法</span><br><span class="line">		$&#123;表达式&#125;</span><br><span class="line">		</span><br><span class="line">	运算</span><br><span class="line">		逻辑运算父  &amp;&amp;(and)  ||(or)   !(not)</span><br><span class="line">		空运算符  empty 用于判断字符串，集合，数组对象是否为<span class="keyword">null</span>或者长度为<span class="number">0</span></span><br><span class="line">	获取值</span><br><span class="line">		<span class="number">1.</span>el表达式只能从域对象中获取值</span><br><span class="line">		<span class="number">2.</span>语法</span><br><span class="line">			$&#123; 域的名称.键的名称 &#125;</span><br><span class="line">			$&#123; 键名 &#125;  一次从最小的域中查找，找到位置</span><br><span class="line">			</span><br><span class="line">			获取对象</span><br><span class="line">				<span class="number">1.</span>对象 $&#123;request.u.name&#125;   u表示 实例化对象，name表示getname方法</span><br><span class="line">				<span class="number">2.</span>list集合 </span><br><span class="line">						$&#123;域的名称.list&#125;  打印集合</span><br><span class="line">						$&#123;域的名称.list[<span class="number">0</span>]&#125; 获取第一个元素</span><br><span class="line">				<span class="number">3.</span>MAP集合</span><br><span class="line">						$&#123;域的名称.键的名称.key名称&#125;</span><br><span class="line">						$&#123;域的名称.键的名称【“key名称”】&#125;</span><br><span class="line">			隐式对象：</span><br><span class="line">				<span class="number">11</span>个隐式对象</span><br><span class="line">					pagecontext</span><br></pre></td></tr></table></figure>

<h3 id="24-8-4-JSTL"><a href="#24-8-4-JSTL" class="headerlink" title="24.8.4 JSTL"></a>24.8.4 JSTL</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">java server tag library</span><br><span class="line"></span><br><span class="line">	作用用于替换  java代码</span><br><span class="line">		导入jar包</span><br><span class="line">		&lt;%@ taglib uri=<span class="string">&quot;&quot;</span> profix%&gt;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		常用标签</span><br><span class="line">			<span class="keyword">if</span>		</span><br><span class="line">				&lt;c:if test=&quot;true&quot;&gt;&lt;/c:if&gt;</span><br><span class="line">			choose  相当于<span class="keyword">switch</span>语句</span><br><span class="line">				&lt;c:choose&gt;</span><br><span class="line">                    &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">                    &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt;</span><br><span class="line">                &lt;/c:choose&gt;</span><br><span class="line">			foreach</span><br><span class="line">			</span><br><span class="line">				&lt;c:forEach begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;10&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span> step=<span class="string">&quot;1&quot;</span> varStatus=<span class="string">&quot;s&quot;</span>&gt;</span><br><span class="line">                    $&#123;i&#125;&lt;br&gt;</span><br><span class="line">                    $&#123;s.index&#125;</span><br><span class="line">                    $&#123;$.count&#125;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<h2 id="24-9-Filter"><a href="#24-9-Filter" class="headerlink" title="24.9 Filter"></a>24.9 Filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">过滤器</span><br><span class="line">	当请求的时候，过滤器可以将一些请求拦截下来，完成一些特殊的功能</span><br><span class="line">	作用</span><br><span class="line">		一般完成通用的操作：登陆验证，登陆过后才能访问</span><br><span class="line">		</span><br><span class="line">		<span class="number">1.</span>定义一个类，让他实现一个接口Filter，</span><br><span class="line">		<span class="number">2.</span>复写里面的方法，</span><br><span class="line">		<span class="number">3.</span>配置拦截路径</span><br><span class="line">			<span class="number">1.</span>webxml配置</span><br><span class="line">				 &lt;filter&gt;</span><br><span class="line">                    &lt;filter-name&gt;demo1&lt;/filter-name&gt;</span><br><span class="line">                    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">servlet</span>.<span class="title">filter</span>.<span class="title">hello</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">                    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">                    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">                &lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">			2.注解</span></span><br><span class="line">				@WebFilter(&quot;/*&quot;)   访问所有资源之前都会拦截</span><br><span class="line">				filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">			<span class="number">3.</span>过滤器执行流程</span><br><span class="line">			<span class="number">4.</span>过滤器生命周期</span><br><span class="line">				init 加载资源</span><br><span class="line">				destroy 释放资源</span><br><span class="line">			<span class="number">5.</span>过滤器配置详情</span><br><span class="line">				拦截路径配置</span><br><span class="line">					<span class="number">1.</span>资源路径  /index.jsp  只有访问index.jsp</span><br><span class="line">					<span class="number">2.</span>拦截目录  /user<span class="comment">/*  访问user下的所有资源</span></span><br><span class="line"><span class="comment">					3.后缀名   *.jsp   访问所有jsp文件</span></span><br><span class="line"><span class="comment">					4./*     拦截所有资源</span></span><br><span class="line"><span class="comment">				拦截方式</span></span><br><span class="line"><span class="comment">					1.注解设置</span></span><br><span class="line"><span class="comment">						dispatchtypes属性</span></span><br><span class="line"><span class="comment">							1.request 默认值，浏览器直接请求</span></span><br><span class="line"><span class="comment">							2.forword	转发来访问资源</span></span><br><span class="line"><span class="comment">							3.include	包含访问资源</span></span><br><span class="line"><span class="comment">							4.error	错误跳转资源</span></span><br><span class="line"><span class="comment">							5.async	异步访问资源</span></span><br><span class="line"><span class="comment">			@WebFilter(value = &quot;/*&quot;,dispatcherTypes = DispatcherType.REQUEST)</span></span><br><span class="line"><span class="comment">			6.过滤器链 配置多个过滤器</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">					注解按照类名字符串比较规则比较值小的先执行 a&gt;b</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">					xml  mapping 谁在上面谁执行</span></span><br></pre></td></tr></table></figure>

<h2 id="24-10-Listener"><a href="#24-10-Listener" class="headerlink" title="24.10 Listener"></a>24.10 Listener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事件  	一件事情</span><br><span class="line">事件源		一件事情发生的地方</span><br><span class="line">监听器		 一个对象，一段代码</span><br><span class="line">注册监听 	将前面三个绑定到一起，当事件源发生事情后，执行监听器代码</span><br><span class="line"></span><br><span class="line">	servletContextListener 接口，去实现</span><br><span class="line">	</span><br><span class="line">	xml</span><br><span class="line">		&lt;listener&gt;</span><br><span class="line">            &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">servlet</span>.<span class="title">listener</span>.<span class="title">Listener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="24-11-ajax-，Json"><a href="#24-11-ajax-，Json" class="headerlink" title="24.11 ajax ，Json"></a>24.11 ajax ，Json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">同步  客户端必须等待服务器的回应，，在等待的期间不能做其他操作</span><br><span class="line">异步	客户端可以干其他的操作，不要等待服务器端的相应</span><br><span class="line"></span><br><span class="line">Json	</span><br><span class="line">	多用于存储交换信息的语法，进行数据的传输，比xml更加快速</span><br><span class="line">	</span><br><span class="line">	解析器</span><br><span class="line">		<span class="comment">//创建jackson核心对象</span></span><br><span class="line">		</span><br><span class="line">		<span class="number">1.</span>java对象转 json</span><br><span class="line">			ObjectMapper map = <span class="keyword">new</span> OBjectMapper()</span><br><span class="line">			<span class="number">1.</span>map.writeValue(参数<span class="number">1</span>，obj);</span><br><span class="line">				File: 将对象转化为json字符串并且保存到文件中</span><br><span class="line">				Writer 将对象转化为json字符串并且填充到字符输出流中</span><br><span class="line">				OUTpoutstrem 将对象转化为json字符串并且填充到字节输出流中</span><br><span class="line">			<span class="number">2.</span>String json = mapper.weiteValueASString(person);</span><br><span class="line">			</span><br><span class="line">			注意</span><br><span class="line">				<span class="number">1.</span><span class="meta">@JsonIgnore</span>	忽略该属性</span><br><span class="line">					加载属性值上面</span><br><span class="line">				<span class="number">2.</span><span class="meta">@Jsonformat(pattern = &quot;yyyy-MM-dd&quot;)</span>  格式化属性</span><br><span class="line">				</span><br><span class="line">				复杂数据转化</span><br><span class="line">					List  数组</span><br><span class="line">					MAp  对象格式一致</span><br><span class="line">				</span><br><span class="line">		<span class="number">2.</span>json转 java</span><br><span class="line">			创建核心对象 OBjectmapper</span><br><span class="line">			调用readvalue(json字符串，转化的类型)</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">mikasa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/11/30/java/">http://yoursite.com/2020/11/30/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">mikasa</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2756099248,2036703181&amp;fm=26&amp;gp=0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/30/java%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=428108013,2443178233&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/30/MYSQL/"><img class="next-cover" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2495164343,1369797041&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySql</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/index/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">mikasa</div><div class="author-info__description">Java,JavaScript,Node,Json,Sql,前端,数据库,后端</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/source/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zcz147258"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">有缘人哦吼！</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">二.规范</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">三.数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">3.1数据类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E8%87%AA%E5%8A%A8%E8%BD%AC%E5%8C%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">3.1.1自动转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">3.1.2强制类型转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">四.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">4.1定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%89%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">4.2方法的三种调用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.3.</span> <span class="toc-text">4.3方法的重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-idea%E4%B8%AD%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">4.</span> <span class="toc-text">五.idea中快捷键</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E6%95%B0%E7%BB%84"><span class="toc-number">5.</span> <span class="toc-text">六.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E5%90%8C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">5.1.</span> <span class="toc-text">6.1同一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%EF%BC%9B%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-number">5.2.</span> <span class="toc-text">6.2数组索引越界；空指针异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">6.3数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Arrays"><span class="toc-number">5.4.</span> <span class="toc-text">6.4 Arrays</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-java%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">七.java的内存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">八.类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">8.1变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81-%E5%B0%81%E8%A3%85"><span class="toc-number">7.2.</span> <span class="toc-text">8.2面向对象三大特征 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-this"><span class="toc-number">7.3.</span> <span class="toc-text">8.3 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">8.4构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E7%BB%A7%E6%89%BF"><span class="toc-number">7.5.</span> <span class="toc-text">8.4面向对象三大特性 继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-super"><span class="toc-number">7.6.</span> <span class="toc-text">8.5 super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6%E6%8A%BD%E8%B1%A1-%E6%96%B9%E6%B3%95abstract"><span class="toc-number">7.7.</span> <span class="toc-text">8.6抽象 方法abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-Object"><span class="toc-number">7.8.</span> <span class="toc-text">8.7 Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-Objects"><span class="toc-number">7.9.</span> <span class="toc-text">8.8 Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.10.</span> <span class="toc-text">8.9可变参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-api%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">九. api的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5Scanner"><span class="toc-number">8.1.</span> <span class="toc-text">1.键盘输入Scanner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-random"><span class="toc-number">8.2.</span> <span class="toc-text">2.random</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-math"><span class="toc-number">8.3.</span> <span class="toc-text">3.math</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.</span> <span class="toc-text">十.匿名对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E9%9B%86%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text">十一.,集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1ArrayList"><span class="toc-number">10.1.</span> <span class="toc-text">11.1ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">11.2包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3%E9%9B%86%E5%90%88"><span class="toc-number">10.3.</span> <span class="toc-text">11.3集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">11.4集合的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-5-iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">11.5 iterator迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-6%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF-foreach"><span class="toc-number">10.6.</span> <span class="toc-text">11.6增强for循环  foreach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-7%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.7.</span> <span class="toc-text">11.7泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.8.</span> <span class="toc-text">11.8数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-9-List"><span class="toc-number">10.9.</span> <span class="toc-text">11.9 List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-10-linkedList"><span class="toc-number">10.10.</span> <span class="toc-text">11.10 linkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-11-Vector"><span class="toc-number">10.11.</span> <span class="toc-text">11.11 Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-12-HashSet"><span class="toc-number">10.12.</span> <span class="toc-text">11.12 HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-13-linkedHashSet"><span class="toc-number">10.13.</span> <span class="toc-text">11.13 linkedHashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-14-%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.14.</span> <span class="toc-text">11.14 集合工具类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-15-Map%E9%9B%86%E5%90%88"><span class="toc-number">10.15.</span> <span class="toc-text">11.15 Map集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-16-linkedhashmap"><span class="toc-number">10.16.</span> <span class="toc-text">11.16 linkedhashmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-17-hashtable"><span class="toc-number">10.17.</span> <span class="toc-text">11.17 hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-18-jdk9-%E6%96%B0%E5%A2%9E%E5%AF%B9%E9%9B%86%E5%90%88"><span class="toc-number">10.18.</span> <span class="toc-text">11.18 jdk9 新增对集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">11.</span> <span class="toc-text">十二.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">11.1.</span> <span class="toc-text">12.1创建字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="toc-number">11.2.</span> <span class="toc-text">12.2字符串的常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">12.3字符串的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">十三.权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-static"><span class="toc-number">12.1.</span> <span class="toc-text">13.1 static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-final"><span class="toc-number">12.2.</span> <span class="toc-text">13.2 final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">12.3.</span> <span class="toc-text">13.3四种权限修饰符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-interface"><span class="toc-number">13.</span> <span class="toc-text">十四.interface</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">14.1接口抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">14.2接口默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">14.3接口的静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">14.4接口的私有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">13.5.</span> <span class="toc-text">14.5接口的常量的定义和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-6%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.6.</span> <span class="toc-text">14.6继承父类并且实现多个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-7%E6%8E%A5%E5%8F%A3%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">13.7.</span> <span class="toc-text">14.7接口之间的多继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7-%E5%A4%9A%E6%80%81"><span class="toc-number">13.8.</span> <span class="toc-text">14.8 面向对象三大特性 多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-9%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">13.9.</span> <span class="toc-text">14.9使用多态的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-11%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">13.10.</span> <span class="toc-text">14.11向上转型和向下转型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">十五.内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.1.</span> <span class="toc-text">15.1成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">15.2 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">15.3匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4%E7%B1%BB%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.4.</span> <span class="toc-text">15.4类，接口作为成员变量类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">十六.时间日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-DateFormat%E7%B1%BB"><span class="toc-number">15.1.</span> <span class="toc-text">16.1 DateFormat类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-Calendar%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">16.1 Calendar类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-System%E7%B1%BB"><span class="toc-number">15.3.</span> <span class="toc-text">16.2 System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-StringBuilder%E7%B1%BB"><span class="toc-number">15.4.</span> <span class="toc-text">16.3 StringBuilder类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E5%BC%82%E5%B8%B8"><span class="toc-number">16.</span> <span class="toc-text">十七.异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-throw"><span class="toc-number">16.1.</span> <span class="toc-text">17.1 throw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-throws"><span class="toc-number">16.2.</span> <span class="toc-text">17.2 throws</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-try-catch"><span class="toc-number">16.3.</span> <span class="toc-text">17.3 try catch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-final%E4%BB%A3%E7%A0%81%E5%BF%AB"><span class="toc-number">16.4.</span> <span class="toc-text">17.4 final代码快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-5%E5%A4%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">16.5.</span> <span class="toc-text">17.5多异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">16.6.</span> <span class="toc-text">17.6自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">十八.多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1%E4%B8%BB%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">18.1主线程，多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">17.2.</span> <span class="toc-text">18.2多线程的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">17.3.</span> <span class="toc-text">18.3匿名内部类实现多线程的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">17.4.</span> <span class="toc-text">18.4线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">17.5.</span> <span class="toc-text">18.5线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-6%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%8A%B6%E6%80%81"><span class="toc-number">17.6.</span> <span class="toc-text">18.6线程通信状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-7%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">17.7.</span> <span class="toc-text">18.7线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-8-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.8.</span> <span class="toc-text">18.8 lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-File-%E7%B1%BB"><span class="toc-number">18.</span> <span class="toc-text">十九.File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">18.1.</span> <span class="toc-text">19.1构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E9%81%8D%E5%8E%86"><span class="toc-number">18.2.</span> <span class="toc-text">19.2创建删除遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-3-IO%E6%B5%81"><span class="toc-number">18.3.</span> <span class="toc-text">19.3 IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-1%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">18.3.1.</span> <span class="toc-text">19.3.1字节输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-2-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">18.3.2.</span> <span class="toc-text">19.3.2 字节输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-3-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">18.3.3.</span> <span class="toc-text">19.3.3 字符输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-4%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">18.3.4.</span> <span class="toc-text">19.3.4字符输出流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-5-%E5%A4%84%E7%90%86IO%E6%B5%81%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">18.3.5.</span> <span class="toc-text">19.3.5 处理IO流中的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-3-6-properties%E9%9B%86%E5%90%88"><span class="toc-number">18.3.6.</span> <span class="toc-text">19.3.6 properties集合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-4-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">18.4.</span> <span class="toc-text">19.4 缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-5-%E8%BD%AC%E5%8C%96%E6%B5%81"><span class="toc-number">18.5.</span> <span class="toc-text">19.5 转化流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-6%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">18.6.</span> <span class="toc-text">19.6序列化和反序列化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">二十.网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-TCP%E9%80%9A%E4%BF%A1"><span class="toc-number">19.1.</span> <span class="toc-text">20.1 TCP通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">19.2.</span> <span class="toc-text">20.2客户端实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">19.3.</span> <span class="toc-text">20.3服务器端代码实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.</span> <span class="toc-text">二十一.函数式接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C-Java-web%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%BC%BA"><span class="toc-number">21.</span> <span class="toc-text">二十二. Java web基础加强</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Junit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">21.1.</span> <span class="toc-text">1. Junit 单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84"><span class="toc-number">21.2.</span> <span class="toc-text">2.反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.3.</span> <span class="toc-text">3.注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-number">22.</span> <span class="toc-text">二十三.数据库操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="toc-number">22.1.</span> <span class="toc-text">23.1数据库范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2%E4%BA%8B%E5%8A%A1"><span class="toc-number">22.2.</span> <span class="toc-text">23.2事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-JDBC"><span class="toc-number">22.3.</span> <span class="toc-text">23.3 JDBC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">22.4.</span> <span class="toc-text">23.4数据库连接池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B-Java-web"><span class="toc-number">23.</span> <span class="toc-text">二十四. Java web</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">23.1.</span> <span class="toc-text">24.1服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-1-tomcat"><span class="toc-number">23.2.</span> <span class="toc-text">24.1 tomcat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-2-servlet"><span class="toc-number">23.3.</span> <span class="toc-text">24.2 servlet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-3-request"><span class="toc-number">23.4.</span> <span class="toc-text">24.3 request</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-4-response"><span class="toc-number">23.5.</span> <span class="toc-text">24.4 response</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-5-cookie"><span class="toc-number">23.6.</span> <span class="toc-text">24.5 cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-6-JSP%E5%85%A5%E9%97%A8"><span class="toc-number">23.7.</span> <span class="toc-text">24.6 JSP入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-7-session"><span class="toc-number">23.8.</span> <span class="toc-text">24.7 session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-8-JSP%E6%B7%B1%E5%85%A5"><span class="toc-number">23.9.</span> <span class="toc-text">24.8 JSP深入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#24-8-1%E6%8C%87%E4%BB%A4"><span class="toc-number">23.9.1.</span> <span class="toc-text">24.8.1指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-8-2-MVC"><span class="toc-number">23.9.2.</span> <span class="toc-text">24.8.2 MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-8-3-El%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.9.3.</span> <span class="toc-text">24.8.3 El表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-8-4-JSTL"><span class="toc-number">23.9.4.</span> <span class="toc-text">24.8.4 JSTL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-9-Filter"><span class="toc-number">23.10.</span> <span class="toc-text">24.9 Filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-10-Listener"><span class="toc-number">23.11.</span> <span class="toc-text">24.10 Listener</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-11-ajax-%EF%BC%8CJson"><span class="toc-number">23.12.</span> <span class="toc-text">24.11 ajax ，Json</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/generator%E5%92%8Citerator/" title="generator和iterator"><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4234896097,4021899470&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="generator和iterator"/></a><div class="content"><a class="title" href="/2020/12/16/generator%E5%92%8Citerator/" title="generator和iterator">generator和iterator</a><time datetime="2020-12-16T03:42:48.398Z" title="发表于 2020-12-16 11:42:48">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/js%E5%8A%A0%E8%A7%A3%E5%AF%86crypto.js/" title="js加解密"><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4234896097,4021899470&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js加解密"/></a><div class="content"><a class="title" href="/2020/12/16/js%E5%8A%A0%E8%A7%A3%E5%AF%86crypto.js/" title="js加解密">js加解密</a><time datetime="2020-12-16T03:41:57.061Z" title="发表于 2020-12-16 11:41:57">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/js%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/" title="js对象数组排序"><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=4234896097,4021899470&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js对象数组排序"/></a><div class="content"><a class="title" href="/2020/12/16/js%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/" title="js对象数组排序">js对象数组排序</a><time datetime="2020-12-16T03:40:27.119Z" title="发表于 2020-12-16 11:40:27">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/React%E7%88%B6%E5%AD%90%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/" title="React父子方法调用"><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2431606259,2554064138&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="React父子方法调用"/></a><div class="content"><a class="title" href="/2020/12/16/React%E7%88%B6%E5%AD%90%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/" title="React父子方法调用">React父子方法调用</a><time datetime="2020-12-16T03:39:04.218Z" title="发表于 2020-12-16 11:39:04">2020-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/16/antd%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/" title="antd表单验证"><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2431606259,2554064138&amp;fm=26&amp;gp=0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="antd表单验证"/></a><div class="content"><a class="title" href="/2020/12/16/antd%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/" title="antd表单验证">antd表单验证</a><time datetime="2020-12-16T03:38:14.395Z" title="发表于 2020-12-16 11:38:14">2020-12-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By mikasa</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'BzB1So5EWrOm2CUDceS299It-gzGzoHsz',
      appKey: 'Ul1N9MAsFqovsupOVB5eoJee',
      placeholder: '记得留下你的暱称和邮箱....可以快速收到回復',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign({}, initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="aplayer no-destroy" data-id="2484225391" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config_change',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})</script></div></body></html>